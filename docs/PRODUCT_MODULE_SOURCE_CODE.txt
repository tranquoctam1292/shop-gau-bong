# PRODUCT MODULE SOURCE CODE

Generated: 2025-12-14 15:24:31

Status: Phase 1-4 Complete (19/22 tasks)


================================================================================




--- FILE: components/admin/ProductForm.tsx ---


'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useToastContext } from '@/components/providers/ToastProvider';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select } from '@/components/ui/select';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Plus, Trash2, Save, X } from 'lucide-react';
import type { MappedProduct, MappedCategory } from '@/lib/utils/productMapper';
import { SEOMetaBox, type SEOMetaBoxData } from './products/SEOMetaBox';
import { ProductFormLayout } from './products/ProductFormLayout';
import { PublishBox } from './products/sidebar/PublishBox';
import { CategoriesBox } from './products/sidebar/CategoriesBox';
import { TagsBox } from './products/sidebar/TagsBox';
import { FeaturedImageBox } from './products/sidebar/FeaturedImageBox';
import { ProductGalleryBox } from './products/sidebar/ProductGalleryBox';
import { ProductLinksBox } from './products/sidebar/ProductLinksBox';
import { ClassicEditor } from './products/ClassicEditor';
import { ShortDescriptionEditor } from './products/ShortDescriptionEditor';
import { ProductDataMetaBox, type ProductDataMetaBoxState, type ProductType } from './products/ProductDataMetaBox';
import { StickyActionBar } from './products/ProductDataMetaBox/StickyActionBar';
import { generateSlug, generateShortId } from '@/lib/utils/slug';

interface ProductVariant {
  id: string;
  size: string;
  color?: string;
  colorCode?: string;
  price: number;
  stock: number;
  image?: string;
  sku?: string;
}

// SEO data is now managed by SEOMetaBox

interface ProductFormData {
  name: string;
  slug: string;
  description: string;
  shortDescription: string;
  sku: string;
  category: string; // Keep for backward compatibility
  categories?: string[]; // Multiple categories support
  tags: string[];
  variants: ProductVariant[];
  // Image fields (new structure)
  _thumbnail_id?: string; // Attachment ID for featured image
  _product_image_gallery?: string; // Comma-separated attachment IDs for gallery
  // Keep images for backward compatibility during migration (will be removed later)
  images?: string[];
  length?: number;
  width?: number;
  height?: number;
  weight?: number;
  isHot: boolean;
  isActive: boolean;
  status: 'draft' | 'publish' | 'trash';
  visibility?: 'public' | 'private' | 'password';
  // New fields for Phase 1
  seo?: SEOMetaBoxData;
  // Product Data Meta Box fields
  productDataMetaBox?: Partial<ProductDataMetaBoxState>;
  // Optimistic locking version
  version?: number;
  // Gift features
  giftFeatures?: {
    giftWrapping: boolean;
    giftMessageEnabled: boolean;
    giftCardEnabled: boolean;
    giftDeliveryDateEnabled: boolean;
  };
  // Media extended
  mediaExtended?: Record<string, any>;
}

interface ProductFormProps {
  productId?: string;
  initialData?: Partial<ProductFormData>;
}

export function ProductForm({ productId, initialData }: ProductFormProps) {
  const router = useRouter();
  const { showToast } = useToastContext();
  const [loading, setLoading] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false); // Prevent double submission
  const [currentProductId, setCurrentProductId] = useState<string | undefined>(productId); // Track current product ID
  const [categories, setCategories] = useState<MappedCategory[]>([]);
  // Image URLs for display (separate from IDs stored in formData)
  const [thumbnailUrl, setThumbnailUrl] = useState<string | undefined>(undefined);
  const [galleryImages, setGalleryImages] = useState<Array<{id: string, thumbnail_url: string, title?: string, altText?: string}>>([]);
  // Local state for input fields to reduce rerenders (onBlur optimization)
  const [localName, setLocalName] = useState<string>('');
  // Publish Box states
  const [scheduledDate, setScheduledDate] = useState<Date | null>(null);
  const [password, setPassword] = useState<string>('');
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [lastAutosaveTime, setLastAutosaveTime] = useState<Date | null>(null);
  const [initialFormData, setInitialFormData] = useState<ProductFormData | null>(null);
  const [formData, setFormData] = useState<ProductFormData>({
    name: '',
    slug: '',
    description: '',
    shortDescription: '',
    sku: '',
    category: '',
    categories: [],
    tags: [],
    variants: [],
    isHot: false,
    isActive: true,
    status: 'draft',
    visibility: 'public',
    _thumbnail_id: undefined,
    _product_image_gallery: undefined,
    seo: {},
    giftFeatures: {
      giftWrapping: false,
      giftMessageEnabled: false,
      giftCardEnabled: false,
      giftDeliveryDateEnabled: false,
    },
    mediaExtended: {},
    productDataMetaBox: {},
    ...initialData,
  });

  // Fetch categories
  useEffect(() => {
    async function fetchCategories() {
      try {
        const response = await fetch('/api/admin/categories');
        const data = await response.json();
        setCategories(data.categories || []);
      } catch (error) {
        console.error('Error fetching categories:', error);
      }
    }
    fetchCategories();
  }, []);

  // Auto-generate slug from name with duplicate check
  useEffect(() => {
    if (!productId && formData.name && !formData.slug) {
      const generateUniqueSlugAsync = async () => {
        const baseSlug = generateSlug(formData.name);
        if (!baseSlug) return;

        // Check if slug exists
        try {
          const response = await fetch(`/api/admin/products/validate-slug?slug=${encodeURIComponent(baseSlug)}`);
          const data = await response.json();
          
          if (data.exists) {
            // Slug exists, generate unique one with random suffix
            let attempts = 0;
            let uniqueSlug = '';
            
            // Try up to 5 times to find a unique slug
            while (attempts < 5) {
              const suffix = generateShortId();
              uniqueSlug = `${baseSlug}-${suffix}`;
              
              const checkResponse = await fetch(`/api/admin/products/validate-slug?slug=${encodeURIComponent(uniqueSlug)}`);
              const checkData = await checkResponse.json();
              
              if (!checkData.exists) {
                setFormData((prev) => ({ ...prev, slug: uniqueSlug }));
                return;
              }
              
              attempts++;
            }
            
            // Fallback: use timestamp if all attempts failed
            setFormData((prev) => ({ ...prev, slug: `${baseSlug}-${Date.now().toString(36)}` }));
          } else {
            // Slug is available
            setFormData((prev) => ({ ...prev, slug: baseSlug }));
          }
        } catch (error) {
          // On error, just use base slug (will be validated on submit)
          console.error('Error checking slug:', error);
          setFormData((prev) => ({ ...prev, slug: baseSlug }));
        }
      };

      generateUniqueSlugAsync();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formData.name, productId]); // formData.slug intentionally excluded to avoid infinite loop

  // Sync localName when formData.name changes from external source (e.g., when product loads)
  // This ensures localName stays in sync with formData.name without causing rerenders on every keystroke
  useEffect(() => {
    if (formData.name !== localName && formData.name) {
      setLocalName(formData.name);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formData.name]); // Only sync when formData.name changes from external source

  // Äá»“ng bá»™ tá»± Ä‘á»™ng: TÃªn sáº£n pháº©m vÃ  MÃ´ táº£ ngáº¯n copy sang SEO náº¿u chÆ°a Ä‘iá»n
  useEffect(() => {
    if (!formData.seo?.seoTitle && formData.name) {
      setFormData((prev) => ({
        ...prev,
        seo: {
          ...prev.seo,
          seoTitle: prev.name,
        },
      }));
    }
    
    if (!formData.seo?.seoDescription && formData.shortDescription) {
      const textOnly = formData.shortDescription.replace(/<[^>]*>/g, '').substring(0, 160);
      if (textOnly) {
        setFormData((prev) => ({
          ...prev,
          seo: {
            ...prev.seo,
            seoDescription: textOnly,
          },
        }));
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formData.name, formData.shortDescription]); // Only sync when name or shortDescription changes

  // Load product data if editing
  useEffect(() => {
    if (productId && !initialData) {
      async function fetchProduct() {
        try {
          const response = await fetch(`/api/admin/products/${productId}`);
          const data = await response.json();
          if (data.product) {
            const product = data.product as MappedProduct;
            const apiProduct = data.product as any;
            
            // Map product data to ProductDataMetaBox state
            // If productDataMetaBox exists in API response, use it directly (with fallbacks)
            // Otherwise, map from product fields
            const metaBoxData: Partial<ProductDataMetaBoxState> = apiProduct.productDataMetaBox ? {
              // Use productDataMetaBox from API if available
              productType: apiProduct.productDataMetaBox.productType || (product.type as ProductDataMetaBoxState['productType']) || 'simple',
              isVirtual: apiProduct.productDataMetaBox.isVirtual || false,
              isDownloadable: apiProduct.productDataMetaBox.isDownloadable || false,
              sku: apiProduct.productDataMetaBox.sku || product.sku || undefined,
              manageStock: apiProduct.productDataMetaBox.manageStock !== undefined ? apiProduct.productDataMetaBox.manageStock : (product.stockQuantity !== null),
              stockQuantity: apiProduct.productDataMetaBox.stockQuantity !== undefined ? apiProduct.productDataMetaBox.stockQuantity : (product.stockQuantity || undefined),
              stockStatus: apiProduct.productDataMetaBox.stockStatus || (product.stockStatus as ProductDataMetaBoxState['stockStatus']) || 'instock',
              weight: apiProduct.productDataMetaBox.weight !== undefined ? apiProduct.productDataMetaBox.weight : (product.weight ? parseFloat(product.weight) : undefined),
              length: apiProduct.productDataMetaBox.length !== undefined ? apiProduct.productDataMetaBox.length : (product.length || undefined),
              width: apiProduct.productDataMetaBox.width !== undefined ? apiProduct.productDataMetaBox.width : (product.width || undefined),
              height: apiProduct.productDataMetaBox.height !== undefined ? apiProduct.productDataMetaBox.height : (product.height || undefined),
              regularPrice: apiProduct.productDataMetaBox.regularPrice !== undefined ? apiProduct.productDataMetaBox.regularPrice : (parseFloat(product.regularPrice) || undefined),
              salePrice: apiProduct.productDataMetaBox.salePrice !== undefined ? apiProduct.productDataMetaBox.salePrice : (product.salePrice && product.regularPrice && parseFloat(product.salePrice) < parseFloat(product.regularPrice) ? parseFloat(product.salePrice) : undefined),
              salePriceStartDate: apiProduct.productDataMetaBox.salePriceStartDate || undefined,
              salePriceEndDate: apiProduct.productDataMetaBox.salePriceEndDate || undefined,
              costPrice: apiProduct.productDataMetaBox.costPrice || undefined,
              lowStockThreshold: apiProduct.productDataMetaBox.lowStockThreshold || undefined,
              backorders: apiProduct.productDataMetaBox.backorders || 'no',
              soldIndividually: apiProduct.productDataMetaBox.soldIndividually || false,
              purchaseNote: apiProduct.productDataMetaBox.purchaseNote || undefined,
              menuOrder: apiProduct.productDataMetaBox.menuOrder || 0,
              enableReviews: apiProduct.productDataMetaBox.enableReviews !== undefined ? apiProduct.productDataMetaBox.enableReviews : true,
              // Include attributes and variations from productDataMetaBox
              attributes: apiProduct.productDataMetaBox.attributes || [],
              variations: apiProduct.productDataMetaBox.variations || [],
            } : {
              // Fallback: Map from product fields if productDataMetaBox doesn't exist
              productType: (product.type as ProductDataMetaBoxState['productType']) || 'simple',
              isVirtual: false,
              isDownloadable: false,
              sku: product.sku || undefined,
              manageStock: product.stockQuantity !== null,
              stockQuantity: product.stockQuantity || undefined,
              stockStatus: (product.stockStatus as ProductDataMetaBoxState['stockStatus']) || 'instock',
              weight: product.weight ? parseFloat(product.weight) : undefined,
              length: product.length || undefined,
              width: product.width || undefined,
              height: product.height || undefined,
              regularPrice: parseFloat(product.regularPrice) || undefined,
              salePrice: product.salePrice && product.regularPrice && parseFloat(product.salePrice) < parseFloat(product.regularPrice)
                ? parseFloat(product.salePrice)
                : undefined,
              attributes: [],
              variations: [],
            };
            // Load scheduledDate and password if available
            if (apiProduct.scheduledDate) {
              setScheduledDate(new Date(apiProduct.scheduledDate));
            }
            if (apiProduct.password) {
              setPassword(apiProduct.password);
            }
            const loadedFormData: ProductFormData = {
              name: product.name,
              slug: product.slug,
              description: product.description || '',
              shortDescription: product.shortDescription || '',
              sku: product.sku || '',
              category: product.categories[0]?.id?.toString() || '',
              categories: product.categories?.map((c) => c.id?.toString()).filter(Boolean) || [],
              tags: product.tags?.map((t) => t.name) || [],
              variants: product.attributes
                ?.find((a) => a.name === 'Size')
                ?.options.map((size, idx) => ({
                  id: `variant-${idx}`,
                  size,
                  price: parseFloat(product.price),
                  stock: product.stockQuantity || 0,
                })) || [],
              // Image fields - try new structure first, fallback to old structure
              _thumbnail_id: (product as any)._thumbnail_id || (product.image?.id?.toString()),
              _product_image_gallery: (product as any)._product_image_gallery ||
                (product.galleryImages?.map((img: any) => img.id?.toString()).filter(Boolean).join(',') || undefined),
              // Keep images for backward compatibility (will be removed later)
              images: [
                product.image?.sourceUrl,
                ...product.galleryImages.map((img) => img.sourceUrl),
              ].filter(Boolean) as string[],
              length: product.length || undefined,
              width: product.width || undefined,
              height: product.height || undefined,
              weight: product.weight ? parseFloat(product.weight) : undefined,
              isHot: false,
              isActive: product.stockStatus === 'instock',
              status: (apiProduct.status as 'draft' | 'publish' | 'trash') || 'draft',
              visibility: (apiProduct.visibility as 'public' | 'private' | 'password') || 'public',
              productDataMetaBox: metaBoxData,
              mediaExtended: apiProduct.mediaExtended || {},
              version: apiProduct.version || 0, // Load version for optimistic locking
            };
            setFormData(loadedFormData);
            // Sync local state for input fields (onBlur optimization)
            setLocalName(loadedFormData.name);
            // Store initial data for dirty check
            setInitialFormData(JSON.parse(JSON.stringify(loadedFormData)));

            // Set image URLs for display
            
            // Set thumbnail
            if (apiProduct._thumbnail_id) {
              // New structure: use thumbnail object if available, fallback to image.sourceUrl
              if (apiProduct.thumbnail) {
                setThumbnailUrl(apiProduct.thumbnail.thumbnail_url || apiProduct.thumbnail.url);
              } else if (product.image?.sourceUrl) {
                setThumbnailUrl(product.image.sourceUrl);
              }
            } else if (product.image?.sourceUrl) {
              // Old structure: use sourceUrl
              setThumbnailUrl(product.image.sourceUrl);
            }

            // Set gallery images with alt text
            const imageAltTexts = apiProduct.mediaExtended?.imageAltTexts || {};
            if (apiProduct._product_image_gallery) {
              // New structure: use gallery array if available
              if (apiProduct.gallery && Array.isArray(apiProduct.gallery)) {
                setGalleryImages(apiProduct.gallery.map((img: any) => ({
                  id: img.id?.toString() || '',
                  thumbnail_url: img.thumbnail_url || img.url,
                  title: img.title,
                  altText: imageAltTexts[img.id?.toString() || ''] || '',
                })));
              } else if (product.galleryImages && product.galleryImages.length > 0) {
                // Fallback: map from galleryImages with IDs from _product_image_gallery
                const galleryIds = apiProduct._product_image_gallery.split(',').filter(Boolean);
                setGalleryImages(product.galleryImages.map((img: any, idx: number) => {
                  const imageId = galleryIds[idx] || `gallery-${idx}`;
                  return {
                    id: imageId,
                    thumbnail_url: img.sourceUrl || img.url,
                    title: img.title || img.alt,
                    altText: imageAltTexts[imageId] || '',
                  };
                }));
              }
            } else if (product.galleryImages && product.galleryImages.length > 0) {
              // Old structure: map from galleryImages
              setGalleryImages(product.galleryImages.map((img: any, idx: number) => {
                const imageId = img.id?.toString() || `gallery-${idx}`;
                return {
                  id: imageId,
                  thumbnail_url: img.sourceUrl || img.url,
                  title: img.title || img.alt,
                  altText: imageAltTexts[imageId] || '',
                };
              }));
            }
          }
        } catch (error) {
          console.error('Error fetching product:', error);
        }
      }
      fetchProduct();
    }
  }, [productId, initialData]);

  // Prepare payload helper
  const preparePayload = () => {
    // Validate required fields
    if (!formData.name.trim()) {
      showToast('Vui lÃ²ng nháº­p tÃªn sáº£n pháº©m', 'error');
      return null;
    }

    // Auto-generate slug if empty
    let slug = formData.slug.trim();
    if (!slug) {
      slug = formData.name
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    }

    // Calculate min/max price from variants
    let minPrice = 0;
    let maxPrice: number | undefined = undefined;
    
    if (formData.variants.length > 0) {
      const prices = formData.variants
        .map((v) => v.price)
        .filter((p) => !isNaN(p) && p >= 0);
      
      if (prices.length > 0) {
        minPrice = Math.min(...prices);
        if (prices.length > 1) {
          maxPrice = Math.max(...prices);
        }
      }
    }

    // Validate minPrice
    if (minPrice < 0 || isNaN(minPrice)) {
      showToast('GiÃ¡ sáº£n pháº©m khÃ´ng há»£p lá»‡', 'error');
      return null;
    }

    // Map categories to categoryIds if needed
    // Support both single category (backward compatibility) and multiple categories
    let categoryIds: string[] = [];
    
    if (formData.categories && formData.categories.length > 0) {
      // Use multiple categories if available
      categoryIds = formData.categories
        .map((catId) => {
          const category = categories.find((c) => c.id === catId || c.databaseId?.toString() === catId);
          return category?.id || catId;
        })
        .filter(Boolean);
    } else if (formData.category) {
      // Fallback to single category
      const selectedCategory = categories.find((c) => c.id === formData.category || c.name === formData.category);
      if (selectedCategory) {
        categoryIds = [selectedCategory.id];
      }
    }

    // Merge ProductDataMetaBox data into payload
    const metaBoxData = formData.productDataMetaBox || {};
    const payload: any = {
      ...formData,
      slug,
      minPrice,
      maxPrice,
      category: categoryIds[0] || formData.category || undefined, // Keep for backward compatibility
      categories: categoryIds.length > 0 ? categoryIds : undefined,
      tags: formData.tags.filter((t) => t.trim().length > 0),
      // Include image IDs in payload
      _thumbnail_id: formData._thumbnail_id || undefined,
      _product_image_gallery: formData._product_image_gallery || undefined,
      // Include version for optimistic locking
      version: formData.version || 0,
      // Include ProductDataMetaBox fields in payload
      sku: metaBoxData.sku || formData.sku,
      length: metaBoxData.length || formData.length,
      width: metaBoxData.width || formData.width,
      height: metaBoxData.height || formData.height,
      weight: metaBoxData.weight || formData.weight,
      // Store full meta box data for future use
      productDataMetaBox: metaBoxData,
    };

    // Populate images array for backward compatibility and frontend display
    // This ensures ProductCard can display images even if _thumbnail_id is pathname
    const imagesArray: string[] = [];
    
    // Add featured image URL if available
    if (thumbnailUrl) {
      imagesArray.push(thumbnailUrl);
    } else if (formData._thumbnail_id && (formData._thumbnail_id.startsWith('http://') || formData._thumbnail_id.startsWith('https://'))) {
      // If _thumbnail_id is already a URL, use it
      imagesArray.push(formData._thumbnail_id);
    }
    
    // Add gallery image URLs if available
    if (galleryImages && galleryImages.length > 0) {
      galleryImages.forEach((img) => {
        if (img.thumbnail_url && !imagesArray.includes(img.thumbnail_url)) {
          imagesArray.push(img.thumbnail_url);
        }
      });
    } else if (formData._product_image_gallery) {
      // Fallback: if galleryImages not available, try to extract URLs from _product_image_gallery
      const galleryIds = formData._product_image_gallery.split(',').filter(Boolean);
      galleryIds.forEach((id) => {
        if (id.startsWith('http://') || id.startsWith('https://')) {
          imagesArray.push(id);
        }
      });
    }
    
    // Set images array if we have URLs (for backward compatibility)
    if (imagesArray.length > 0) {
      payload.images = imagesArray;
    } else {
      // Remove old images field if empty (migration to new structure)
      delete payload.images;
    }

    return payload;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await handleSave('publish');
  };

  // Check if form has unsaved changes
  const isDirty = (): boolean => {
    if (!productId && !currentProductId) {
      // New product: check if any field is filled
      return !!(formData.name || formData.slug || formData.description);
    }
    
    if (!initialFormData) {
      return false; // No initial data to compare
    }
    
    // Deep compare formData with initialFormData
    return JSON.stringify(formData) !== JSON.stringify(initialFormData);
  };

  const handleSave = async (saveStatus: 'draft' | 'publish' | 'keep' = 'keep') => {
    // Prevent double submission
    if (isSubmitting) {
      return;
    }

    // Check if form is dirty (only for "keep" status - "LÆ°u thay Ä‘á»•i")
    if (saveStatus === 'keep' && !isDirty()) {
      // No changes, show message and return
      showToast('KhÃ´ng cÃ³ thay Ä‘á»•i nÃ o Ä‘á»ƒ lÆ°u', 'info');
      return;
    }

    setIsSubmitting(true);
    setLoading(true);

    try {
      const payload = preparePayload();
      if (!payload) {
        setLoading(false);
        setIsSubmitting(false);
        return;
      }

      // Determine final status:
      // - 'keep': Keep current status (for "LÆ°u thay Ä‘á»•i" button)
      // - 'draft': Force to draft (for "LÆ°u nhÃ¡p" button)
      // - 'publish': Force to publish (for "Xuáº¥t báº£n" button)
      const effectiveProductId = currentProductId || productId;
      let finalStatus: 'draft' | 'publish' | 'trash' = formData.status || 'draft';
      
      if (saveStatus === 'draft') {
        finalStatus = 'draft';
      } else if (saveStatus === 'publish') {
        finalStatus = 'publish';
      } else if (saveStatus === 'keep') {
        // Keep current status, but default to 'draft' for new products
        if (!effectiveProductId && !formData.status) {
          finalStatus = 'draft';
        } else {
          finalStatus = formData.status || 'draft';
        }
      }
      
      if (scheduledDate && scheduledDate > new Date()) {
        // If scheduled for future, keep as draft until scheduled time
        finalStatus = 'draft';
      }

      // Override status based on save action
      const finalPayload = {
        ...payload,
        status: finalStatus,
        scheduledDate: scheduledDate ? scheduledDate.toISOString() : undefined,
        password: formData.visibility === 'password' ? password : undefined,
      };

      // Use effectiveProductId already defined above
      const url = effectiveProductId
        ? `/api/admin/products/${effectiveProductId}`
        : '/api/admin/products';
      const method = effectiveProductId ? 'PUT' : 'POST';

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(finalPayload),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        
        // Handle optimistic locking conflict
        if (response.status === 409 && errorData.code === 'VERSION_MISMATCH') {
          showToast(
            'Sáº£n pháº©m Ä‘Ã£ Ä‘Æ°á»£c chá»‰nh sá»­a bá»Ÿi ngÆ°á»i khÃ¡c. Vui lÃ²ng lÃ m má»›i trang vÃ  thá»­ láº¡i.',
            'error'
          );
          // Optionally refresh the product data
          if (currentProductId) {
            setTimeout(() => {
              window.location.reload();
            }, 2000); // Give user time to read the message
          }
          setIsSubmitting(false);
          setLoading(false);
          return;
        }
        
        // Parse error message from server
        let errorMessage = 'CÃ³ lá»—i xáº£y ra khi lÆ°u sáº£n pháº©m';
        
        if (errorData.error) {
          errorMessage = errorData.error;
        } else if (errorData.message) {
          errorMessage = errorData.message;
        } else if (errorData.details && Array.isArray(errorData.details)) {
          // Zod validation errors
          const firstError = errorData.details[0];
          if (firstError?.path && firstError?.message) {
            errorMessage = `${firstError.path.join('.')}: ${firstError.message}`;
          }
        }
        
        showToast(errorMessage, 'error');
        setIsSubmitting(false);
        setLoading(false);
        return;
      }
      
      const result = await response.json();
      
      // Update version after successful save
      const updatedVersion = result.product?.version;
      if (updatedVersion !== undefined) {
        setFormData((prev) => ({ ...prev, version: updatedVersion }));
      }
      
      // Clear unsaved changes flag after successful save
      setHasUnsavedChanges(false);
      setLastAutosaveTime(new Date());
      
      // Update initialFormData after successful save (including new version)
      const savedFormData = JSON.parse(JSON.stringify({
        ...formData,
        version: updatedVersion !== undefined ? updatedVersion : formData.version,
      }));
      setInitialFormData(savedFormData);
      
      // If creating new product, update productId immediately to prevent duplicate autosave
      if (!effectiveProductId && result.product?._id) {
        const newProductId = result.product._id;
        setCurrentProductId(newProductId); // Update state immediately
        // Update URL with new product ID
        router.push(`/admin/products/${newProductId}/edit`);
        router.refresh();
      } else {
        // Just refresh if editing
        router.refresh();
      }
    } catch (error: any) {
      console.error('Error saving product:', error);
      const errorMessage = error?.message || 'CÃ³ lá»—i xáº£y ra khi lÆ°u sáº£n pháº©m';
      showToast(errorMessage, 'error');
    } finally {
      setLoading(false);
      setIsSubmitting(false);
    }
  };

  const handlePublish = async () => {
    await handleSave('publish');
  };

  const handleSaveDraft = async () => {
    // "LÆ°u nhÃ¡p" button in PublishBox - force to draft
    await handleSave('draft');
  };

  const handleSaveChanges = async () => {
    // "LÆ°u thay Ä‘á»•i" button in StickyActionBar - keep current status
    // This prevents published products from disappearing from frontend
    await handleSave('keep');
  };

  const handleAutosave = async () => {
    // Prevent autosave if:
    // 1. Currently submitting (manual save in progress)
    // 2. No productId and no currentProductId (don't create new products via autosave)
    if (isSubmitting) {
      return;
    }

    // Use currentProductId (may have been set by previous save)
    const effectiveProductId = currentProductId || productId;
    
    // Only autosave if product already exists (don't create new products via autosave)
    if (!effectiveProductId) {
      return;
    }

    // Silent autosave (no loading state, no alerts)
    try {
      const payload = preparePayload();
      if (!payload) return;

      // Preserve current status instead of forcing to draft
      // This prevents published products from being reverted to draft
      const finalPayload = {
        ...payload,
        status: formData.status || 'draft', // Preserve current status
      };

      const url = `/api/admin/products/${effectiveProductId}`;
      const method = 'PUT'; // Always use PUT for autosave (product must exist)

      await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(finalPayload),
      });

      setLastAutosaveTime(new Date());
    } catch (error) {
      console.error('Autosave failed:', error);
    }
  };

  const handleDelete = async () => {
    if (!productId) return;

    if (confirm('Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n di chuyá»ƒn sáº£n pháº©m nÃ y vÃ o thÃ¹ng rÃ¡c?')) {
      setLoading(true);
      try {
        const response = await fetch(`/api/admin/products/${productId}`, {
          method: 'DELETE',
        });

        if (!response.ok) {
          const error = await response.json();
          const errorMessage = error?.error || error?.message || 'CÃ³ lá»—i xáº£y ra';
          showToast(errorMessage, 'error');
          return;
        }

        // Redirect to products list
        router.push('/admin/products');
      } catch (error: any) {
        console.error('Error deleting product:', error);
        showToast('CÃ³ lá»—i xáº£y ra khi xÃ³a sáº£n pháº©m', 'error');
      } finally {
        setLoading(false);
      }
    }
  };

  // Track unsaved changes - compare with initial state
  useEffect(() => {
    // Simple check: if form has been modified (name or description changed from initial)
    // In production, you might want a more sophisticated comparison
    const hasChanges = 
      formData.name !== (initialData?.name || '') ||
      formData.description !== (initialData?.description || '') ||
      formData.shortDescription !== (initialData?.shortDescription || '');
    
    setHasUnsavedChanges(hasChanges);
  }, [formData.name, formData.description, formData.shortDescription, initialData]);

  // Variant management functions removed - now handled by VariantFormEnhanced component
  // Tag management functions removed - now handled by TagsBox component
  // Image management functions removed - now handled by FeaturedImageBox and ProductGalleryBox

  // Fetch popular tags (from existing products)
  const fetchPopularTags = async (): Promise<string[]> => {
    try {
      // Fetch tags from API or use existing tags from products
      // For now, return empty array - can be enhanced later
      return [];
    } catch (error) {
      console.error('Error fetching popular tags:', error);
      return [];
    }
  };

  // Sidebar content
  const sidebarContent = (
    <>
      {/* Publish Box */}
      <PublishBox
        status={formData.status}
        isActive={formData.isActive}
        visibility={formData.visibility}
        scheduledDate={scheduledDate}
        password={password}
        onStatusChange={(status) => setFormData((prev) => ({ ...prev, status }))}
        onIsActiveChange={(isActive) => setFormData((prev) => ({ ...prev, isActive }))}
        onVisibilityChange={(visibility) => setFormData((prev) => ({ ...prev, visibility }))}
        onPasswordChange={setPassword}
        onScheduledDateChange={setScheduledDate}
        onPublish={handlePublish}
        onSaveDraft={handleSaveDraft}
        onDelete={handleDelete}
        loading={loading || isSubmitting}
        productId={currentProductId || productId}
        productSlug={formData.slug}
        hasUnsavedChanges={hasUnsavedChanges}
        onAutosave={handleAutosave}
        lastAutosaveTime={lastAutosaveTime}
      />

      {/* Categories Box */}
      <CategoriesBox
        categories={categories}
        selectedCategories={formData.categories || (formData.category ? [formData.category] : [])}
        primaryCategory={formData.categories?.[0] || formData.category || undefined}
        onCategoriesChange={(categoryIds) => {
          setFormData((prev) => ({
            ...prev,
            categories: categoryIds,
            category: categoryIds[0] || '', // Keep for backward compatibility
          }));
        }}
        onPrimaryCategoryChange={(categoryId) => {
          if (categoryId) {
            setFormData((prev) => ({
              ...prev,
              categories: categoryId ? [categoryId, ...(prev.categories || []).filter(id => id !== categoryId)] : prev.categories,
              category: categoryId || prev.category,
            }));
          }
        }}
      />

      {/* Tags Box */}
      <TagsBox
        tags={formData.tags}
        onTagsChange={(tags) => setFormData((prev) => ({ ...prev, tags }))}
        onFetchPopularTags={fetchPopularTags}
      />

      {/* Featured Image Box */}
      <FeaturedImageBox
        thumbnailId={formData._thumbnail_id}
        thumbnailUrl={thumbnailUrl}
        altText={formData.mediaExtended?.imageAltTexts?.[formData._thumbnail_id || ''] || ''}
        onImageChange={(attachmentId, thumbUrl) => {
          setFormData((prev) => ({
            ...prev,
            _thumbnail_id: attachmentId,
          }));
          setThumbnailUrl(thumbUrl);
        }}
        onImageRemove={() => {
          setFormData((prev) => ({
            ...prev,
            _thumbnail_id: undefined,
            mediaExtended: {
              ...prev.mediaExtended,
              imageAltTexts: {
                ...prev.mediaExtended?.imageAltTexts,
                [prev._thumbnail_id || '']: undefined,
              },
            },
          }));
          setThumbnailUrl(undefined);
        }}
        onAltTextChange={(altText) => {
          if (formData._thumbnail_id) {
            const thumbnailId = formData._thumbnail_id;
            setFormData((prev) => ({
              ...prev,
              mediaExtended: {
                ...prev.mediaExtended,
                imageAltTexts: {
                  ...prev.mediaExtended?.imageAltTexts,
                  [thumbnailId]: altText,
                },
              },
            }));
          }
        }}
      />

      {/* Product Gallery Box */}
      <ProductGalleryBox
        galleryImages={galleryImages}
        onImagesChange={(images) => {
          setGalleryImages(images);
          // Update _product_image_gallery with comma-separated IDs
          // Also update alt texts in mediaExtended
          const altTexts: Record<string, string> = {};
          images.forEach((img) => {
            if (img.altText) {
              altTexts[img.id] = img.altText;
            }
          });
          setFormData((prev) => ({
            ...prev,
            _product_image_gallery: images.map(img => img.id).join(','),
            mediaExtended: {
              ...prev.mediaExtended,
              imageAltTexts: {
                ...prev.mediaExtended?.imageAltTexts,
                ...altTexts,
              },
            },
          }));
        }}
        onAltTextChange={(imageId, altText) => {
          setFormData((prev) => ({
            ...prev,
            mediaExtended: {
              ...prev.mediaExtended,
              imageAltTexts: {
                ...prev.mediaExtended?.imageAltTexts,
                [imageId]: altText,
              },
            },
          }));
        }}
      />


      {/* Product Links Box */}
      <ProductLinksBox
        slug={formData.slug}
        productId={productId}
        status={formData.status}
        onSlugChange={(slug) => setFormData((prev) => ({ ...prev, slug }))}
      />
    </>
  );

  // Header content
  const headerContent = (
    <div>
      <Input
        type="text"
        placeholder="Nháº­p tÃªn sáº£n pháº©m..."
        value={localName}
        onChange={(e) => setLocalName(e.target.value)}
        onBlur={(e) => {
          setFormData((prev) => ({ ...prev, name: e.target.value }));
        }}
        className="text-2xl font-bold border-0 p-0 focus-visible:ring-0 focus-visible:ring-offset-0"
      />
    </div>
  );

  return (
    <form onSubmit={handleSubmit}>
      <ProductFormLayout header={headerContent} sidebar={sidebarContent}>
      {/* Basic Information */}
      <Card>
        <CardHeader>
          <CardTitle>ThÃ´ng tin cÆ¡ báº£n</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          <div>
            <Label htmlFor="name">TÃªn sáº£n pháº©m *</Label>
            <Input
              id="name"
              value={localName}
              onChange={(e) => setLocalName(e.target.value)}
              onBlur={(e) => {
                setFormData((prev) => ({ ...prev, name: e.target.value }));
              }}
              required
              className="mt-2"
            />
          </div>


          <div>
            <Label htmlFor="description">MÃ´ táº£ chi tiáº¿t</Label>
            <div className="mt-2">
              <ClassicEditor
                value={formData.description}
                onChange={(html) => setFormData((prev) => ({ ...prev, description: html }))}
                placeholder="MÃ´ táº£ Ä‘áº§y Ä‘á»§ vá» sáº£n pháº©m (hiá»ƒn thá»‹ trong trang chi tiáº¿t)"
              />
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Product Flags */}
      <Card>
        <CardHeader>
          <CardTitle>Thiáº¿t láº­p sáº£n pháº©m</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center gap-3">
            <label className="flex items-center gap-2 cursor-pointer">
              <input
                type="checkbox"
                checked={formData.isHot}
                onChange={(e) => setFormData((prev) => ({ ...prev, isHot: e.target.checked }))}
                className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
              />
              <span className="text-sm">Sáº£n pháº©m ná»•i báº­t</span>
            </label>
            <p className="text-xs text-muted-foreground">
              (Hiá»ƒn thá»‹ sáº£n pháº©m nÃ y á»Ÿ vá»‹ trÃ­ ná»•i báº­t trÃªn trang chá»§)
            </p>
          </div>
        </CardContent>
      </Card>

      {/* Product Data Meta Box */}
      <ProductDataMetaBox
        data={formData.productDataMetaBox}
        onChange={(metaBoxData) => {
          // Use functional update to batch state changes and prevent race conditions
          setFormData((prev) => {
            // Deep comparison to check if metaBoxData actually changed
            const prevMetaBox = prev.productDataMetaBox || {};
            const hasMetaBoxChanges = 
              prevMetaBox.productType !== metaBoxData.productType ||
              prevMetaBox.isVirtual !== metaBoxData.isVirtual ||
              prevMetaBox.isDownloadable !== metaBoxData.isDownloadable ||
              prevMetaBox.sku !== metaBoxData.sku ||
              prevMetaBox.costPrice !== metaBoxData.costPrice ||
              prevMetaBox.regularPrice !== metaBoxData.regularPrice ||
              prevMetaBox.salePrice !== metaBoxData.salePrice ||
              prevMetaBox.salePriceStartDate !== metaBoxData.salePriceStartDate ||
              prevMetaBox.salePriceEndDate !== metaBoxData.salePriceEndDate ||
              JSON.stringify(prevMetaBox.downloadableFiles) !== JSON.stringify(metaBoxData.downloadableFiles) ||
              prevMetaBox.length !== metaBoxData.length ||
              prevMetaBox.width !== metaBoxData.width ||
              prevMetaBox.height !== metaBoxData.height ||
              prevMetaBox.weight !== metaBoxData.weight ||
              prevMetaBox.shippingClass !== metaBoxData.shippingClass ||
              prevMetaBox.manageStock !== metaBoxData.manageStock ||
              prevMetaBox.stockQuantity !== metaBoxData.stockQuantity ||
              prevMetaBox.stockStatus !== metaBoxData.stockStatus ||
              prevMetaBox.lowStockThreshold !== metaBoxData.lowStockThreshold ||
              prevMetaBox.backorders !== metaBoxData.backorders ||
              prevMetaBox.soldIndividually !== metaBoxData.soldIndividually ||
              JSON.stringify(prevMetaBox.attributes) !== JSON.stringify(metaBoxData.attributes) ||
              JSON.stringify(prevMetaBox.variations) !== JSON.stringify(metaBoxData.variations) ||
              prevMetaBox.purchaseNote !== metaBoxData.purchaseNote ||
              prevMetaBox.menuOrder !== metaBoxData.menuOrder ||
              prevMetaBox.enableReviews !== metaBoxData.enableReviews;
            
            // Check if synced fields changed
            const hasSyncedFieldChanges = 
              prev.sku !== (metaBoxData.sku || prev.sku) ||
              prev.length !== (metaBoxData.length || prev.length) ||
              prev.width !== (metaBoxData.width || prev.width) ||
              prev.height !== (metaBoxData.height || prev.height) ||
              prev.weight !== (metaBoxData.weight || prev.weight);
            
            if (!hasMetaBoxChanges && !hasSyncedFieldChanges) {
              return prev;
            }
            
            return {
              ...prev,
              productDataMetaBox: metaBoxData,
              // Sync some fields from meta box to form data
              sku: metaBoxData.sku || prev.sku,
              length: metaBoxData.length || prev.length,
              width: metaBoxData.width || prev.width,
              height: metaBoxData.height || prev.height,
              weight: metaBoxData.weight || prev.weight,
            };
          });
        }}
        productId={productId}
      />

      {/* Short Description Editor - Náº±m dÆ°á»›i ProductDataMetaBox vÃ  trÃªn SEO Meta Box */}
      <Card>
        <CardHeader>
          <CardTitle>MÃ´ táº£ ngáº¯n</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            <p className="text-sm text-muted-foreground">
              Äoáº¡n vÄƒn báº£n &quot;má»“i&quot; hiá»ƒn thá»‹ ngay bÃªn cáº¡nh áº£nh sáº£n pháº©m vÃ  phÃ­a trÃªn nÃºt Mua hÃ ng á»Ÿ giao diá»‡n Frontend.
            </p>
            <ShortDescriptionEditor
              value={formData.shortDescription}
              onChange={(html) => {
                setFormData((prev) => {
                  const newData = { ...prev, shortDescription: html };
                  
                  // Äá»“ng bá»™ tá»± Ä‘á»™ng: Copy sang SEO náº¿u chÆ°a Ä‘iá»n
                  if (!newData.seo?.seoDescription && html) {
                    // Strip HTML tags for SEO description (max 160 chars)
                    const textOnly = html.replace(/<[^>]*>/g, '').substring(0, 160);
                    if (textOnly) {
                      newData.seo = {
                        ...newData.seo,
                        seoDescription: textOnly,
                      };
                    }
                  }
                  
                  return newData;
                });
              }}
            />
          </div>
        </CardContent>
      </Card>

      {/* SEO Meta Box - Náº±m sau Short Description Editor */}
      <SEOMetaBox
        data={formData.seo || {}}
        onChange={(seo) => {
          setFormData((prev) => {
            // Sync slug from SEO Meta Box to formData.slug if changed
            const newSlug = seo.slug && seo.slug !== prev.slug ? seo.slug : prev.slug;
            return { ...prev, seo, slug: newSlug };
          });
        }}
        productName={formData.name}
        productPrice={formData.productDataMetaBox?.regularPrice || 0}
        productSalePrice={formData.productDataMetaBox?.salePrice}
        productSku={formData.productDataMetaBox?.sku || formData.sku || ''}
        productCategory={formData.categories && formData.categories[0] ? categories.find(c => c.id === formData.categories![0])?.name || '' : ''}
        productBrand={''} // TODO: Get from product attributes or meta
        productShortDescription={formData.shortDescription || ''}
        productDescription={formData.description || ''}
        productImage={thumbnailUrl || ''}
        productStockStatus={formData.productDataMetaBox?.stockStatus || 'instock'}
        productStockQuantity={formData.productDataMetaBox?.stockQuantity || 0}
        productRating={5.0} // TODO: Get from product reviews
        productSlug={formData.slug || ''}
        siteName="Shop Gáº¥u BÃ´ng"
        hasRelatedProducts={
          // Check if product has related products (upsell/cross-sell)
          // Note: collectionCombo was removed, but we can check other sources if available
          false // TODO: Implement when upsell/cross-sell feature is available
        }
      />
      </ProductFormLayout>

      {/* Sticky Action Bar */}
      <StickyActionBar
        onSave={handleSaveChanges}
        onPreview={() => {
          if (productId && formData.slug) {
            window.open(`/products/${formData.slug}`, '_blank');
          }
        }}
        loading={loading}
        productId={productId}
        productSlug={formData.slug}
      />
    </form>
  );
}




--- FILE: components/admin/products/PriceInput.tsx ---


'use client';

import { Input } from '@/components/ui/input';
import { forwardRef, useState, useEffect } from 'react';

interface PriceInputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'value' | 'onChange'> {
  value?: number;
  onChange?: (value: number | undefined) => void;
  showCurrency?: boolean;
}

/**
 * PriceInput Component
 * Formats number with thousand separators (10.000.000) while typing
 * Stores actual number value (without formatting)
 */
export const PriceInput = forwardRef<HTMLInputElement, PriceInputProps>(
  ({ value, onChange, showCurrency = true, className, ...props }, ref) => {
    const [displayValue, setDisplayValue] = useState<string>('');

    // Update display value when value prop changes
    useEffect(() => {
      if (value === undefined || value === null || isNaN(value)) {
        setDisplayValue('');
      } else {
        // Format with thousand separators
        const formatted = new Intl.NumberFormat('vi-VN').format(value);
        setDisplayValue(formatted);
      }
    }, [value]);

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const inputValue = e.target.value;
      
      // Remove all non-digit characters (keep only numbers)
      const numericValue = inputValue.replace(/[^\d]/g, '');
      
      // Update display with formatting
      if (numericValue === '') {
        setDisplayValue('');
        onChange?.(undefined);
      } else {
        const num = parseInt(numericValue, 10);
        if (!isNaN(num)) {
          // Format with thousand separators for display
          const formatted = new Intl.NumberFormat('vi-VN').format(num);
          setDisplayValue(formatted);
          // Pass numeric value to onChange
          onChange?.(num);
        }
      }
    };

    const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
      // On blur, ensure display value matches the numeric value
      if (value !== undefined && value !== null && !isNaN(value)) {
        const formatted = new Intl.NumberFormat('vi-VN').format(value);
        setDisplayValue(formatted);
      }
    };

    return (
      <div className="relative">
        <Input
          {...props}
          ref={ref}
          type="text"
          inputMode="numeric"
          value={displayValue}
          onChange={handleChange}
          onBlur={handleBlur}
          className={showCurrency ? `${className || ''} pr-20` : className}
        />
        {showCurrency && (
          <span className="absolute right-3 top-1/2 -translate-y-1/2 text-sm text-muted-foreground pointer-events-none">
            Ä‘
          </span>
        )}
      </div>
    );
  }
);

PriceInput.displayName = 'PriceInput';



--- FILE: components/admin/products/ClassicEditor.tsx ---


'use client';

import { useState, useRef, useEffect } from 'react';
import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image';
import Link from '@tiptap/extension-link';
// TextAlign and Underline extensions - will be added if needed
// import TextAlign from '@tiptap/extension-text-align';
// import Underline from '@tiptap/extension-underline';
import Placeholder from '@tiptap/extension-placeholder';
import { Iframe, VideoEmbedWrapper } from '@/lib/tiptap/extensions/Iframe';
import { convertVideoUrlToEmbed, isStandaloneVideoUrl } from '@/lib/utils/videoEmbed';
import { useToastContext } from '@/components/providers/ToastProvider';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { MediaLibraryModal } from './MediaLibraryModal';
import { InlineImageToolbar } from './InlineImageToolbar';
import { ImageEditorErrorBoundary } from './ImageEditorErrorBoundary';
import {
  Bold,
  Italic,
  Underline as UnderlineIcon,
  Strikethrough,
  List,
  ListOrdered,
  Quote,
  Minus,
  AlignLeft,
  AlignCenter,
  AlignRight,
  AlignJustify,
  Link as LinkIcon,
  Image as ImageIcon,
  Code,
  Undo,
  Redo,
  Type,
  Palette,
  MoreHorizontal,
  Upload,
  Eye,
  Code2,
} from 'lucide-react';

interface ClassicEditorProps {
  value: string;
  onChange: (html: string) => void;
  placeholder?: string;
}

/**
 * Classic WordPress Editor Component
 * Features:
 * - Visual/Text mode toggle
 * - Add Media button vá»›i modal
 * - Full toolbar (2 hÃ ng)
 * - Text mode vá»›i QuickTags
 */
export function ClassicEditor({ value, onChange, placeholder = 'Nháº­p ná»™i dung...' }: ClassicEditorProps) {
  const { showToast } = useToastContext();
  const [mode, setMode] = useState<'visual' | 'text'>('visual');
  const [showToolbarRow2, setShowToolbarRow2] = useState(false);
  const [showMediaModal, setShowMediaModal] = useState(false);
  const [textContent, setTextContent] = useState(value);
  const [isToolbarSticky, setIsToolbarSticky] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const toolbarRef = useRef<HTMLDivElement>(null);
  const editorContainerRef = useRef<HTMLDivElement>(null);

  // Initialize Tiptap editor for Visual mode
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [1, 2, 3, 4, 5, 6],
        },
      }),
      Image.extend({
        addAttributes() {
          return {
            ...this.parent?.(),
            class: {
              default: null,
              parseHTML: element => element.getAttribute('class'),
              renderHTML: attributes => {
                if (!attributes.class) {
                  return {};
                }
                return {
                  class: attributes.class,
                };
              },
            },
            style: {
              default: null,
              parseHTML: element => element.getAttribute('style'),
              renderHTML: attributes => {
                if (!attributes.style) {
                  return {};
                }
                return {
                  style: attributes.style,
                };
              },
            },
            width: {
              default: null,
              parseHTML: element => element.getAttribute('width'),
              renderHTML: attributes => {
                if (!attributes.width) {
                  return {};
                }
                return {
                  width: attributes.width,
                };
              },
            },
            height: {
              default: null,
              parseHTML: element => element.getAttribute('height'),
              renderHTML: attributes => {
                if (!attributes.height) {
                  return {};
                }
                return {
                  height: attributes.height,
                };
              },
            },
          };
        },
      }).configure({
        inline: true,
        allowBase64: false, // Disable Base64 - force server upload via paste handler
        HTMLAttributes: {
          class: 'max-w-full h-auto',
        },
      }),
      Link.configure({
        openOnClick: false,
        HTMLAttributes: {
          class: 'text-primary underline',
          target: '_blank',
          rel: 'noopener noreferrer',
        },
      }),
      // Video Embed extensions for video embeds
      VideoEmbedWrapper,
      Iframe,
      // TextAlign and Underline will be added when extensions are installed
      // TextAlign.configure({
      //   types: ['heading', 'paragraph'],
      // }),
      // Underline,
      Placeholder.configure({
        placeholder,
      }),
    ],
    content: value || '',
    immediatelyRender: false, // Fix SSR hydration mismatch
    onUpdate: ({ editor }) => {
      const html = editor.getHTML();
      // Only update if different to avoid unnecessary re-renders
      if (html !== textContent) {
        setTextContent(html);
        onChange(html);
      }
    },
    editorProps: {
      attributes: {
        class: 'prose prose-sm max-w-none focus:outline-none min-h-[300px] p-4 border border-input rounded-b',
      },
    },
  });

  // Handle paste events for video embedding and image upload
  useEffect(() => {
    if (!editor) return;

    const handlePaste = async (view: any, event: ClipboardEvent) => {
      const clipboardData = event.clipboardData || (window as any).clipboardData;
      if (!clipboardData) {
        return false;
      }

      // Handle image paste - upload to server instead of Base64
      const items = Array.from(clipboardData.items) as DataTransferItem[];
      const imageItem = items.find((item) => item.type.indexOf('image') !== -1);
      
      if (imageItem) {
        event.preventDefault();
        const file = imageItem.getAsFile();
        if (file) {
          // Upload image to server
          try {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('folder', 'products'); // Organize in products folder
            
            const response = await fetch('/api/admin/media/upload', {
              method: 'POST',
              body: formData,
            });

            if (response.ok) {
              const data = await response.json();
              const imageUrl = data.url || data.media?.url;
              
              if (imageUrl) {
                // Insert image with server URL
                editor.chain().focus().setImage({ 
                  src: imageUrl,
                  alt: file.name || 'Product image'
                }).run();
                
                // Update content
                const newHtml = editor.getHTML();
                setTextContent(newHtml);
                onChange(newHtml);
                return true;
              }
            } else {
              const errorData = await response.json().catch(() => ({}));
              showToast(errorData.error || 'KhÃ´ng thá»ƒ upload áº£nh. Vui lÃ²ng thá»­ láº¡i.', 'error');
            }
          } catch (error) {
            console.error('Error uploading pasted image:', error);
            showToast('CÃ³ lá»—i xáº£y ra khi upload áº£nh. Vui lÃ²ng thá»­ láº¡i.', 'error');
          }
        }
        return true;
      }

      const pastedText = clipboardData.getData('text/plain');
      if (!pastedText) return false;

      // Check if pasted text is a standalone video URL
      const isStandalone = isStandaloneVideoUrl(pastedText);
      
      if (isStandalone) {
        const embedHtml = convertVideoUrlToEmbed(pastedText.trim());
        
        if (embedHtml) {
          event.preventDefault();
          // Insert video embed using editor commands
          // Parse HTML to extract iframe and create proper node structure
          setTimeout(() => {
            
            // Parse HTML to extract wrapper and iframe for proper node structure
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = embedHtml;
            const wrapper = tempDiv.querySelector('div.video-embed-wrapper');
            const iframe = wrapper?.querySelector('iframe');
            
            if (wrapper && iframe) {
              // Extract attributes
              const wrapperStyle = wrapper.getAttribute('style') || '';
              const wrapperClass = wrapper.getAttribute('class') || 'video-embed-wrapper';
              const iframeAttrs = {
                src: iframe.getAttribute('src') || '',
                frameborder: iframe.getAttribute('frameborder') || '0',
                allowfullscreen: iframe.hasAttribute('allowfullscreen'),
                allow: iframe.getAttribute('allow') || '',
                style: iframe.getAttribute('style') || '',
                class: iframe.getAttribute('class') || '',
                width: iframe.getAttribute('width') || '100%',
                height: iframe.getAttribute('height') || '400px',
              };
              
              // Insert as proper node structure to avoid paragraph wrapping
              editor.chain()
                .focus()
                .insertContent({
                  type: 'videoEmbedWrapper',
                  attrs: {
                    style: wrapperStyle,
                    class: wrapperClass,
                  },
                  content: [
                    {
                      type: 'iframe',
                      attrs: iframeAttrs,
                    },
                  ],
                })
                .run();
            } else {
              // Fallback to raw HTML insert
              editor.commands.insertContent(embedHtml);
            }
          }, 0);
          return true;
        }
      }

      // Check if pasted text contains video URLs on their own lines
      const lines = pastedText.split('\n');
      let hasVideoUrl = false;
      let modifiedText = pastedText;

      for (const line of lines) {
        const trimmedLine = line.trim();
        if (isStandaloneVideoUrl(trimmedLine)) {
          const embedHtml = convertVideoUrlToEmbed(trimmedLine);
          if (embedHtml) {
            hasVideoUrl = true;
            // Replace the line with embed HTML
            modifiedText = modifiedText.replace(trimmedLine, embedHtml);
          }
        }
      }

      if (hasVideoUrl) {
        event.preventDefault();
        setTimeout(() => {
          editor.commands.insertContent(modifiedText);
        }, 0);
        return true;
      }

      return false; // Let default paste handler handle it
    };

    // Register paste handler
    editor.view.dom.addEventListener('paste', (e: ClipboardEvent) => {
      handlePaste(editor.view, e);
    });

    return () => {
      editor.view.dom.removeEventListener('paste', handlePaste as any);
    };
  }, [editor]);

  // Sync content when value prop changes (only if different to avoid loops)
  useEffect(() => {
    if (!editor || value === undefined) return;
    
    const currentHtml = editor.getHTML();
    // Only update if value is actually different and not from our own onChange
    if (value !== currentHtml) {
      editor.commands.setContent(value || '');
      setTextContent(value || '');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value]); // Only depend on value, not editor or textContent

  // Sync between Visual and Text mode
  useEffect(() => {
    if (!editor) return;
    
    if (mode === 'text') {
      // When switching to text mode, get HTML from visual editor
      const html = editor.getHTML();
      if (html !== textContent) {
        setTextContent(html);
      }
    } else if (mode === 'visual') {
      // When switching to visual mode, set content from text mode
      const currentHtml = editor.getHTML();
      // Only update if textContent is different to avoid unnecessary updates
      if (textContent && textContent !== currentHtml) {
        editor.commands.setContent(textContent);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [mode]); // Only trigger on mode change, not editor or textContent

  // Keyboard shortcuts handler
  useEffect(() => {
    if (!editor) return;

    const handleKeyDown = (event: KeyboardEvent) => {
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      const ctrlKey = isMac ? event.metaKey : event.ctrlKey;
      const altKey = event.altKey;
      const shiftKey = event.shiftKey;

      // System shortcuts (Ctrl/Cmd + ...)
      if (ctrlKey && !altKey && !shiftKey) {
        switch (event.key.toLowerCase()) {
          case 'z':
            if (!event.shiftKey) {
              event.preventDefault();
              if (mode === 'visual') {
                editor.commands.undo();
              }
            }
            break;
          case 'y':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.redo();
            }
            break;
          case 'a':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.selectAll();
            } else if (textareaRef.current) {
              textareaRef.current.select();
            }
            break;
          case 'b':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.toggleBold();
            } else {
              insertQuickTag('<strong>', '</strong>');
            }
            break;
          case 'i':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.toggleItalic();
            } else {
              insertQuickTag('<em>', '</em>');
            }
            break;
          case 'u':
            event.preventDefault();
            if (mode === 'visual') {
              const { from, to } = editor.state.selection;
              const selectedText = editor.state.doc.textBetween(from, to);
              if (selectedText) {
                editor.chain().focus().deleteSelection().insertContent(`<u>${selectedText}</u>`).run();
              } else {
                editor.chain().focus().insertContent('<u></u>').run();
              }
            } else {
              insertQuickTag('<u>', '</u>');
            }
            break;
          case 'k':
            event.preventDefault();
            addLink();
            break;
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
            event.preventDefault();
            if (mode === 'visual') {
              const level = parseInt(event.key) as 1 | 2 | 3 | 4 | 5 | 6;
              editor.commands.toggleHeading({ level });
            }
            break;
          case '7':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.setParagraph();
            }
            break;
        }
      }

      // Alt + Shift shortcuts
      if (altKey && shiftKey && !ctrlKey) {
        switch (event.key.toLowerCase()) {
          case 'x':
            event.preventDefault();
            if (mode === 'visual') {
              const { from, to } = editor.state.selection;
              const selectedText = editor.state.doc.textBetween(from, to);
              if (selectedText) {
                editor.chain().focus().deleteSelection().insertContent(`<code>${selectedText}</code>`).run();
              } else {
                editor.chain().focus().insertContent('<code></code>').run();
              }
            } else {
              insertQuickTag('<code>', '</code>');
            }
            break;
          case 'd':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.toggleStrike();
            } else {
              insertQuickTag('<del>', '</del>');
            }
            break;
          case 'q':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.toggleBlockquote();
            } else {
              insertQuickTag('<blockquote>', '</blockquote>');
            }
            break;
          case 'u':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.toggleBulletList();
            } else {
              if (textareaRef.current) {
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = textarea.value.substring(start, end);
                if (selectedText) {
                  const lines = selectedText.split('\n').filter(l => l.trim());
                  const listItems = lines.map(line => `<li>${line}</li>`).join('\n');
                  const newText = textarea.value.substring(0, start) + `<ul>\n${listItems}\n</ul>` + textarea.value.substring(end);
                  setTextContent(newText);
                  onChange(newText);
                  textarea.value = newText;
                  textarea.focus();
                } else {
                  insertQuickTag('<ul>\n<li>', '</li>\n</ul>');
                }
              }
            }
            break;
          case 'o':
            event.preventDefault();
            if (mode === 'visual') {
              editor.commands.toggleOrderedList();
            } else {
              if (textareaRef.current) {
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = textarea.value.substring(start, end);
                if (selectedText) {
                  const lines = selectedText.split('\n').filter(l => l.trim());
                  const listItems = lines.map(line => `<li>${line}</li>`).join('\n');
                  const newText = textarea.value.substring(0, start) + `<ol>\n${listItems}\n</ol>` + textarea.value.substring(end);
                  setTextContent(newText);
                  onChange(newText);
                  textarea.value = newText;
                  textarea.focus();
                } else {
                  insertQuickTag('<ol>\n<li>', '</li>\n</ol>');
                }
              }
            }
            break;
          case 'm':
            event.preventDefault();
            setShowMediaModal(true);
            break;
          case 'l':
            event.preventDefault();
            if (mode === 'visual' && editor) {
              const { from, to } = editor.state.selection;
              const selectedContent = editor.state.doc.textBetween(from, to);
              if (selectedContent) {
                editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: left;">${selectedContent}</p>`).run();
              } else {
                editor.chain().focus().insertContent('<p style="text-align: left;"></p>').run();
              }
            }
            break;
          case 'c':
            event.preventDefault();
            if (mode === 'visual' && editor) {
              const { from, to } = editor.state.selection;
              const selectedContent = editor.state.doc.textBetween(from, to);
              if (selectedContent) {
                editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: center;">${selectedContent}</p>`).run();
              } else {
                editor.chain().focus().insertContent('<p style="text-align: center;"></p>').run();
              }
            }
            break;
          case 'r':
            event.preventDefault();
            if (mode === 'visual' && editor) {
              const { from, to } = editor.state.selection;
              const selectedContent = editor.state.doc.textBetween(from, to);
              if (selectedContent) {
                editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: right;">${selectedContent}</p>`).run();
              } else {
                editor.chain().focus().insertContent('<p style="text-align: right;"></p>').run();
              }
            }
            break;
          case 'j':
            event.preventDefault();
            if (mode === 'visual' && editor) {
              const { from, to } = editor.state.selection;
              const selectedContent = editor.state.doc.textBetween(from, to);
              if (selectedContent) {
                editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: justify;">${selectedContent}</p>`).run();
              } else {
                editor.chain().focus().insertContent('<p style="text-align: justify;"></p>').run();
              }
            }
            break;
          case 'z':
            event.preventDefault();
            setShowToolbarRow2(!showToolbarRow2);
            break;
          case 'w':
            // Distraction-free mode - Toggle fullscreen editor
            event.preventDefault();
            if (editor) {
              const editorElement = editor.view.dom.closest('.border');
              if (editorElement) {
                if (document.fullscreenElement) {
                  document.exitFullscreen();
                } else {
                  editorElement.requestFullscreen().catch(() => {
                    // Fallback: Just hide/show toolbar
                    setShowToolbarRow2(false);
                  });
                }
              }
            }
            break;
        }
      }
    };

    const editorElement = editor.view.dom;
    editorElement.addEventListener('keydown', handleKeyDown);

    return () => {
      editorElement.removeEventListener('keydown', handleKeyDown);
    };
  }, [editor, mode, showToolbarRow2]);

  // Handle sticky toolbar on scroll
  useEffect(() => {
    let timeoutId: NodeJS.Timeout | null = null;
    let cleanup: (() => void) | null = null;

    const setupScrollListener = () => {
      if (!toolbarRef.current || !editorContainerRef.current) {
        // Retry after a short delay
        timeoutId = setTimeout(setupScrollListener, 100);
        return;
      }

      const handleScroll = () => {
        const toolbar = toolbarRef.current;
        const container = editorContainerRef.current;
        if (!toolbar || !container) return;

        const toolbarRect = toolbar.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const scrollY = window.scrollY || window.pageYOffset;
        
        // Admin bar height (32px as per spec)
        const adminBarHeight = 32;
        
        // Check if toolbar is scrolled out of view (above viewport)
        const isToolbarOutOfView = toolbarRect.top < adminBarHeight;
        
        // Check if we're still within the editor container
        // Toolbar should hide when we scroll past the container bottom or before container top
        const containerTop = containerRect.top;
        const containerBottom = containerRect.bottom;
        const isWithinContainer = containerTop < window.innerHeight && containerBottom > adminBarHeight;
        
        // Show sticky toolbar when:
        // 1. Original toolbar is scrolled out of view (above viewport)
        // 2. We're still within the editor container
        // 3. We've scrolled down (not at the top)
        if (isToolbarOutOfView && isWithinContainer && scrollY > 0) {
          setIsToolbarSticky(true);
        } else {
          setIsToolbarSticky(false);
        }
      };

      // Listen to scroll events on window
      window.addEventListener('scroll', handleScroll, { passive: true });
      // Also check on initial load and resize
      handleScroll();
      window.addEventListener('resize', handleScroll, { passive: true });

      // Store cleanup function
      cleanup = () => {
        window.removeEventListener('scroll', handleScroll);
        window.removeEventListener('resize', handleScroll);
      };
    };

    // Start checking for refs
    setupScrollListener();

    // Return cleanup function
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      if (cleanup) {
        cleanup();
      }
    };
  }, []);

  const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newContent = e.target.value;
    setTextContent(newContent);
    onChange(newContent);
  };

  const insertQuickTag = (openTag: string, closeTag: string, insertText?: string) => {
    if (!textareaRef.current) return;

    const textarea = textareaRef.current;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = textarea.value.substring(start, end);
    const textToWrap = insertText || selectedText;

    let newText: string;
    let newCursorPos: number;

    if (textToWrap) {
      // Wrap text (either selected or provided)
      newText =
        textarea.value.substring(0, start) +
        `${openTag}${textToWrap}${closeTag}` +
        textarea.value.substring(end);
      newCursorPos = start + openTag.length + textToWrap.length + closeTag.length;
    } else {
      // Insert tags at cursor (for empty selection)
      newText =
        textarea.value.substring(0, start) +
        `${openTag}${closeTag}` +
        textarea.value.substring(end);
      newCursorPos = start + openTag.length;
    }

    // Update state and textarea
    setTextContent(newText);
    onChange(newText);
    
    // Use setTimeout to ensure DOM is updated before setting selection
    setTimeout(() => {
      if (textareaRef.current) {
        textareaRef.current.value = newText;
        textareaRef.current.setSelectionRange(newCursorPos, newCursorPos);
        textareaRef.current.focus();
      }
    }, 0);
  };

  const addLink = () => {
    const url = prompt('Nháº­p URL:');
    if (!url) return;

    // Validate URL format
    try {
      new URL(url);
    } catch {
      // If not valid URL, try adding http://
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        const fullUrl = `http://${url}`;
        try {
          new URL(fullUrl);
          // Use fullUrl if valid
        } catch {
          alert('URL khÃ´ng há»£p lá»‡');
          return;
        }
      } else {
        alert('URL khÃ´ng há»£p lá»‡');
        return;
      }
    }

    if (mode === 'visual' && editor) {
      const selectedText = editor.state.doc.textBetween(
        editor.state.selection.from,
        editor.state.selection.to
      );
      if (selectedText) {
        // If text is selected, wrap it in link
        editor.chain().focus().setLink({ href: url }).run();
      } else {
        // If no text selected, insert link with URL as text
        editor.chain().focus().insertContent(`<a href="${url}">${url}</a>`).run();
      }
    } else {
      // Text mode
      if (!textareaRef.current) return;
      const textarea = textareaRef.current;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const selectedText = textarea.value.substring(start, end);
      
      const linkText = selectedText || prompt('Nháº­p text hiá»ƒn thá»‹:', url) || url;
      insertQuickTag(`<a href="${url}">`, '</a>', linkText);
    }
  };

  const addImage = () => {
    const url = prompt('Nháº­p URL hÃ¬nh áº£nh:');
    if (!url) return;

    // Validate URL
    try {
      new URL(url);
    } catch {
      // If not valid URL, try adding http://
      if (!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('/')) {
        alert('URL khÃ´ng há»£p lá»‡. Vui lÃ²ng nháº­p URL Ä‘áº§y Ä‘á»§ (VD: https://example.com/image.jpg)');
        return;
      }
    }

    const alt = prompt('Nháº­p Alt Text (tÃ¹y chá»n):') || '';

    if (mode === 'visual' && editor) {
      editor.chain().focus().setImage({ src: url, alt: alt || undefined }).run();
      // Update textContent for sync
      const newHtml = editor.getHTML();
      setTextContent(newHtml);
      onChange(newHtml);
    } else {
      const imgTag = alt ? `<img src="${url}" alt="${alt}" />` : `<img src="${url}" />`;
      if (textareaRef.current) {
        const textarea = textareaRef.current;
        const start = textarea.selectionStart;
        const newText =
          textarea.value.substring(0, start) + imgTag + textarea.value.substring(start);
        setTextContent(newText);
        onChange(newText);
        
        setTimeout(() => {
          if (textareaRef.current) {
            textareaRef.current.value = newText;
            const newCursorPos = start + imgTag.length;
            textareaRef.current.setSelectionRange(newCursorPos, newCursorPos);
            textareaRef.current.focus();
          }
        }, 0);
      }
    }
  };

  const insertReadMore = () => {
    if (mode === 'visual' && editor) {
      editor.chain().focus().insertContent('<!--more-->').run();
      // Update textContent for sync
      const newHtml = editor.getHTML();
      setTextContent(newHtml);
      onChange(newHtml);
    } else {
      if (textareaRef.current) {
        const textarea = textareaRef.current;
        const start = textarea.selectionStart;
        const newText =
          textarea.value.substring(0, start) +
          '<!--more-->' +
          textarea.value.substring(start);
        setTextContent(newText);
        onChange(newText);
        
        setTimeout(() => {
          if (textareaRef.current) {
            textareaRef.current.value = newText;
            const newCursorPos = start + '<!--more-->'.length;
            textareaRef.current.setSelectionRange(newCursorPos, newCursorPos);
            textareaRef.current.focus();
          }
        }, 0);
      }
    }
  };

  // Show loading state while editor initializes
  if (!editor) {
    return (
      <div className="border border-input rounded-lg p-8 text-center">
        <div className="text-muted-foreground">Äang táº£i editor...</div>
      </div>
    );
  }

  return (
    <div ref={editorContainerRef} className="border border-input rounded-lg overflow-hidden">
      {/* Sticky Toolbar (shown when scrolled) */}
      {isToolbarSticky && toolbarRef.current && (() => {
        const toolbar = toolbarRef.current;
        if (!toolbar) return null;
        const toolbarRect = toolbar.getBoundingClientRect();
        const stickyStyle: React.CSSProperties = {
          position: 'fixed',
          top: '32px',
          width: toolbar.offsetWidth + 'px',
          left: toolbarRect.left + 'px',
          zIndex: 9999,
          backgroundColor: 'hsl(var(--muted))',
        };
        return (
          <div 
            className="bg-muted border-b border-input shadow-lg"
            style={stickyStyle}
          >
          {/* Render same toolbar content as original - using same structure */}
          {/* Row 1: Add Media + Core Formatting */}
          <div className="flex items-center gap-1 p-2 border-b border-input">
            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={() => setShowMediaModal(true)}
              className="mr-2"
            >
              <Upload className="h-4 w-4 mr-1" />
              ThÃªm Media
            </Button>
            <div className="h-6 w-px bg-border mx-1" />
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().toggleBold().run();
                } else if (mode === 'text') {
                  insertQuickTag('<strong>', '</strong>');
                }
              }}
              className={mode === 'visual' && editor?.isActive('bold') ? 'bg-background' : ''}
              disabled={mode === 'text' && !textareaRef.current}
              title="In Ä‘áº­m (Ctrl+B)"
            >
              <Bold className="h-4 w-4" />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().toggleItalic().run();
                } else if (mode === 'text') {
                  insertQuickTag('<em>', '</em>');
                }
              }}
              className={mode === 'visual' && editor?.isActive('italic') ? 'bg-background' : ''}
              disabled={mode === 'text' && !textareaRef.current}
              title="In nghiÃªng (Ctrl+I)"
            >
              <Italic className="h-4 w-4" />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().toggleStrike().run();
                } else if (mode === 'text') {
                  insertQuickTag('<del>', '</del>');
                }
              }}
              className={mode === 'visual' && editor?.isActive('strike') ? 'bg-background' : ''}
              disabled={mode === 'text' && !textareaRef.current}
              title="Gáº¡ch ngang"
            >
              <Strikethrough className="h-4 w-4" />
            </Button>
            <div className="h-6 w-px bg-border mx-1" />
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().toggleBulletList().run();
                } else if (mode === 'text' && textareaRef.current) {
                  const textarea = textareaRef.current;
                  const start = textarea.selectionStart;
                  const end = textarea.selectionEnd;
                  const selectedText = textarea.value.substring(start, end);
                  if (selectedText) {
                    const lines = selectedText.split('\n').filter(l => l.trim());
                    const listItems = lines.map(line => `<li>${line}</li>`).join('\n');
                    const newText = textarea.value.substring(0, start) + `<ul>\n${listItems}\n</ul>` + textarea.value.substring(end);
                    setTextContent(newText);
                    onChange(newText);
                    textarea.value = newText;
                    textarea.focus();
                  } else {
                    insertQuickTag('<ul>\n<li>', '</li>\n</ul>');
                  }
                }
              }}
              className={mode === 'visual' && editor?.isActive('bulletList') ? 'bg-background' : ''}
              disabled={mode === 'text' && !textareaRef.current}
              title="Danh sÃ¡ch khÃ´ng thá»© tá»±"
            >
              <List className="h-4 w-4" />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().toggleOrderedList().run();
                } else if (mode === 'text' && textareaRef.current) {
                  const textarea = textareaRef.current;
                  const start = textarea.selectionStart;
                  const end = textarea.selectionEnd;
                  const selectedText = textarea.value.substring(start, end);
                  if (selectedText) {
                    const lines = selectedText.split('\n').filter(l => l.trim());
                    const listItems = lines.map(line => `<li>${line}</li>`).join('\n');
                    const newText = textarea.value.substring(0, start) + `<ol>\n${listItems}\n</ol>` + textarea.value.substring(end);
                    setTextContent(newText);
                    onChange(newText);
                    textarea.value = newText;
                    textarea.focus();
                  } else {
                    insertQuickTag('<ol>\n<li>', '</li>\n</ol>');
                  }
                }
              }}
              className={mode === 'visual' && editor?.isActive('orderedList') ? 'bg-background' : ''}
              disabled={mode === 'text' && !textareaRef.current}
              title="Danh sÃ¡ch cÃ³ thá»© tá»±"
            >
              <ListOrdered className="h-4 w-4" />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().toggleBlockquote().run();
                } else if (mode === 'text') {
                  insertQuickTag('<blockquote>', '</blockquote>');
                }
              }}
              className={mode === 'visual' && editor?.isActive('blockquote') ? 'bg-background' : ''}
              disabled={mode === 'text' && !textareaRef.current}
              title="TrÃ­ch dáº«n"
            >
              <Quote className="h-4 w-4" />
            </Button>
            <div className="h-6 w-px bg-border mx-1" />
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().setHorizontalRule().run();
                } else if (mode === 'text' && textareaRef.current) {
                  const textarea = textareaRef.current;
                  const start = textarea.selectionStart;
                  const newText = textarea.value.substring(0, start) + '<hr />' + textarea.value.substring(start);
                  setTextContent(newText);
                  onChange(newText);
                  setTimeout(() => {
                    if (textareaRef.current) {
                      textareaRef.current.value = newText;
                      textareaRef.current.setSelectionRange(start + '<hr />'.length, start + '<hr />'.length);
                      textareaRef.current.focus();
                    }
                  }, 0);
                }
              }}
              disabled={mode === 'text' && !textareaRef.current}
              title="ÄÆ°á»ng káº» ngang"
            >
              <Minus className="h-4 w-4" />
            </Button>
            <div className="h-6 w-px bg-border mx-1" />
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={addLink}
              title="ChÃ¨n/Sá»­a liÃªn káº¿t"
            >
              <LinkIcon className="h-4 w-4" />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={insertReadMore}
              title="Tháº» Äá»c tiáº¿p"
            >
              <Type className="h-4 w-4" />
            </Button>
            <div className="flex-1" />
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => setShowToolbarRow2(!showToolbarRow2)}
              title="Má»Ÿ rá»™ng thanh cÃ´ng cá»¥"
            >
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </div>
          {/* Row 2: Advanced Formatting (Toggle) */}
          {showToolbarRow2 && (
            <div className="flex items-center gap-1 p-2 border-b border-input">
              <Select
                defaultValue="paragraph"
                onValueChange={(value) => {
                  if (mode === 'visual' && editor) {
                    if (value === 'paragraph') {
                      editor.chain().focus().setParagraph().run();
                    } else if (value.startsWith('heading')) {
                      const level = parseInt(value.replace('heading', '')) as 1 | 2 | 3 | 4 | 5 | 6;
                      editor.chain().focus().toggleHeading({ level }).run();
                    }
                  }
                }}
                disabled={mode === 'text'}
              >
                <SelectTrigger className="w-40 h-8 text-xs">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="paragraph">Äoáº¡n vÄƒn</SelectItem>
                  <SelectItem value="heading1">TiÃªu Ä‘á» 1</SelectItem>
                  <SelectItem value="heading2">TiÃªu Ä‘á» 2</SelectItem>
                  <SelectItem value="heading3">TiÃªu Ä‘á» 3</SelectItem>
                  <SelectItem value="heading4">TiÃªu Ä‘á» 4</SelectItem>
                  <SelectItem value="heading5">TiÃªu Ä‘á» 5</SelectItem>
                  <SelectItem value="heading6">TiÃªu Ä‘á» 6</SelectItem>
                </SelectContent>
              </Select>
              <div className="h-6 w-px bg-border mx-1" />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={() => {
                  if (editor) {
                    const { from, to } = editor.state.selection;
                    const selectedText = editor.state.doc.textBetween(from, to);
                    if (selectedText) {
                      editor.chain().focus().deleteSelection().insertContent(`<u>${selectedText}</u>`).run();
                    } else {
                      editor.chain().focus().insertContent('<u></u>').run();
                    }
                  }
                }}
                title="Gáº¡ch chÃ¢n"
              >
                <UnderlineIcon className="h-4 w-4" />
              </Button>
              <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={() => {
                  if (editor) {
                    const { from, to } = editor.state.selection;
                    const selectedContent = editor.state.doc.textBetween(from, to);
                    if (selectedContent) {
                      editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: justify;">${selectedContent}</p>`).run();
                    } else {
                      const { $from } = editor.state.selection;
                      const paragraph = $from.node(-1);
                      if (paragraph && paragraph.type.name === 'paragraph') {
                        const paraText = paragraph.textContent;
                        const paraStart = $from.start(-1);
                        const paraEnd = $from.end(-1);
                        editor.chain().focus().setTextSelection({ from: paraStart, to: paraEnd }).deleteSelection().insertContent(`<p style="text-align: justify;">${paraText}</p>`).run();
                      } else {
                        editor.chain().focus().insertContent('<p style="text-align: justify;"></p>').run();
                      }
                    }
                  }
                }}
                title="CÄƒn Ä‘á»u 2 bÃªn"
              >
                <AlignJustify className="h-4 w-4" />
              </Button>
              <div className="h-6 w-px bg-border mx-1" />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={() => {
                  const color = prompt('Nháº­p mÃ£ mÃ u (VD: #FF0000):');
                  if (!color) return;
                  const colorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
                  if (!colorRegex.test(color) && !['red', 'blue', 'green', 'black', 'white'].includes(color.toLowerCase())) {
                    alert('MÃ£ mÃ u khÃ´ng há»£p lá»‡. Sá»­ dá»¥ng format #RRGGBB hoáº·c tÃªn mÃ u.');
                    return;
                  }
                  if (mode === 'visual' && editor) {
                    const { from, to } = editor.state.selection;
                    const selectedText = editor.state.doc.textBetween(from, to);
                    if (selectedText) {
                      editor.chain().focus().deleteSelection().insertContent(`<span style="color: ${color};">${selectedText}</span>`).run();
                    } else {
                      editor.chain().focus().insertContent(`<span style="color: ${color};">text</span>`).run();
                    }
                  } else if (mode === 'text' && textareaRef.current) {
                    const textarea = textareaRef.current;
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    const selectedText = textarea.value.substring(start, end);
                    const wrappedText = selectedText || 'text';
                    const newText = textarea.value.substring(0, start) + `<span style="color: ${color};">${wrappedText}</span>` + textarea.value.substring(end);
                    setTextContent(newText);
                    onChange(newText);
                    setTimeout(() => {
                      if (textareaRef.current) {
                        textareaRef.current.value = newText;
                        const newCursorPos = start + `<span style="color: ${color};">${wrappedText}</span>`.length;
                        textareaRef.current.setSelectionRange(newCursorPos, newCursorPos);
                        textareaRef.current.focus();
                      }
                    }, 0);
                  }
                }}
                disabled={mode === 'text' && !textareaRef.current}
                title="MÃ u chá»¯"
              >
                <Palette className="h-4 w-4" />
              </Button>
              <div className="h-6 w-px bg-border mx-1" />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={() => {
                  if (mode === 'visual' && editor) {
                    editor.chain().focus().unsetBold().unsetItalic().unsetStrike().run();
                  }
                }}
                disabled={mode === 'text' || !editor?.can().unsetBold()}
                title="Táº©y Ä‘á»‹nh dáº¡ng"
              >
                <Code className="h-4 w-4" />
              </Button>
            </div>
          )}
          </div>
        );
      })()}

      {/* Toolbar */}
      <div ref={toolbarRef} className="bg-muted border-b border-input">
        {/* Row 1: Add Media + Core Formatting */}
        <div className="flex items-center gap-1 p-2 border-b border-input">
          {/* Add Media Button */}
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={() => setShowMediaModal(true)}
            className="mr-2"
          >
            <Upload className="h-4 w-4 mr-1" />
            ThÃªm Media
          </Button>

          <div className="h-6 w-px bg-border mx-1" />

          {/* Core Formatting */}
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                editor.chain().focus().toggleBold().run();
              } else if (mode === 'text') {
                insertQuickTag('<strong>', '</strong>');
              }
            }}
            className={mode === 'visual' && editor?.isActive('bold') ? 'bg-background' : ''}
            disabled={mode === 'text' && !textareaRef.current}
            title="In Ä‘áº­m (Ctrl+B)"
          >
            <Bold className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                editor.chain().focus().toggleItalic().run();
              } else if (mode === 'text') {
                insertQuickTag('<em>', '</em>');
              }
            }}
            className={mode === 'visual' && editor?.isActive('italic') ? 'bg-background' : ''}
            disabled={mode === 'text' && !textareaRef.current}
            title="In nghiÃªng (Ctrl+I)"
          >
            <Italic className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                editor.chain().focus().toggleStrike().run();
              } else if (mode === 'text') {
                insertQuickTag('<del>', '</del>');
              }
            }}
            className={mode === 'visual' && editor?.isActive('strike') ? 'bg-background' : ''}
            disabled={mode === 'text' && !textareaRef.current}
            title="Gáº¡ch ngang"
          >
            <Strikethrough className="h-4 w-4" />
          </Button>

          <div className="h-6 w-px bg-border mx-1" />

          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                editor.chain().focus().toggleBulletList().run();
              } else if (mode === 'text' && textareaRef.current) {
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = textarea.value.substring(start, end);
                if (selectedText) {
                  const lines = selectedText.split('\n').filter(l => l.trim());
                  const listItems = lines.map(line => `<li>${line}</li>`).join('\n');
                  const newText = textarea.value.substring(0, start) + `<ul>\n${listItems}\n</ul>` + textarea.value.substring(end);
                  setTextContent(newText);
                  onChange(newText);
                  textarea.value = newText;
                  textarea.focus();
                } else {
                  insertQuickTag('<ul>\n<li>', '</li>\n</ul>');
                }
              }
            }}
            className={mode === 'visual' && editor?.isActive('bulletList') ? 'bg-background' : ''}
            disabled={mode === 'text' && !textareaRef.current}
            title="Danh sÃ¡ch khÃ´ng thá»© tá»±"
          >
            <List className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                editor.chain().focus().toggleOrderedList().run();
              } else if (mode === 'text' && textareaRef.current) {
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = textarea.value.substring(start, end);
                if (selectedText) {
                  const lines = selectedText.split('\n').filter(l => l.trim());
                  const listItems = lines.map(line => `<li>${line}</li>`).join('\n');
                  const newText = textarea.value.substring(0, start) + `<ol>\n${listItems}\n</ol>` + textarea.value.substring(end);
                  setTextContent(newText);
                  onChange(newText);
                  textarea.value = newText;
                  textarea.focus();
                } else {
                  insertQuickTag('<ol>\n<li>', '</li>\n</ol>');
                }
              }
            }}
            className={mode === 'visual' && editor?.isActive('orderedList') ? 'bg-background' : ''}
            disabled={mode === 'text' && !textareaRef.current}
            title="Danh sÃ¡ch cÃ³ thá»© tá»±"
          >
            <ListOrdered className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                editor.chain().focus().toggleBlockquote().run();
              } else if (mode === 'text') {
                insertQuickTag('<blockquote>', '</blockquote>');
              }
            }}
            className={mode === 'visual' && editor?.isActive('blockquote') ? 'bg-background' : ''}
            disabled={mode === 'text' && !textareaRef.current}
            title="TrÃ­ch dáº«n"
          >
            <Quote className="h-4 w-4" />
          </Button>

          <div className="h-6 w-px bg-border mx-1" />

          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                editor.chain().focus().setHorizontalRule().run();
              } else if (mode === 'text' && textareaRef.current) {
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const newText = textarea.value.substring(0, start) + '<hr />' + textarea.value.substring(start);
                setTextContent(newText);
                onChange(newText);
                setTimeout(() => {
                  if (textareaRef.current) {
                    textareaRef.current.value = newText;
                    textareaRef.current.setSelectionRange(start + '<hr />'.length, start + '<hr />'.length);
                    textareaRef.current.focus();
                  }
                }, 0);
              }
            }}
            disabled={mode === 'text' && !textareaRef.current}
            title="ÄÆ°á»ng káº» ngang"
          >
            <Minus className="h-4 w-4" />
          </Button>

          <div className="h-6 w-px bg-border mx-1" />

          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                const { from, to } = editor.state.selection;
                const selectedContent = editor.state.doc.textBetween(from, to);
                if (selectedContent) {
                  editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: left;">${selectedContent}</p>`).run();
                } else {
                  const { $from } = editor.state.selection;
                  const paragraph = $from.node(-1);
                  if (paragraph && paragraph.type.name === 'paragraph') {
                    const paraText = paragraph.textContent;
                    const paraStart = $from.start(-1);
                    const paraEnd = $from.end(-1);
                    editor.chain().focus().setTextSelection({ from: paraStart, to: paraEnd }).deleteSelection().insertContent(`<p style="text-align: left;">${paraText}</p>`).run();
                  } else {
                    editor.chain().focus().insertContent('<p style="text-align: left;"></p>').run();
                  }
                }
              }
              // Alignment buttons don't work well in text mode, so disable them
            }}
            disabled={mode === 'text'}
            title="CÄƒn trÃ¡i"
          >
            <AlignLeft className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                const { from, to } = editor.state.selection;
                const selectedContent = editor.state.doc.textBetween(from, to);
                if (selectedContent) {
                  editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: center;">${selectedContent}</p>`).run();
                } else {
                  const { $from } = editor.state.selection;
                  const paragraph = $from.node(-1);
                  if (paragraph && paragraph.type.name === 'paragraph') {
                    const paraText = paragraph.textContent;
                    const paraStart = $from.start(-1);
                    const paraEnd = $from.end(-1);
                    editor.chain().focus().setTextSelection({ from: paraStart, to: paraEnd }).deleteSelection().insertContent(`<p style="text-align: center;">${paraText}</p>`).run();
                  } else {
                    editor.chain().focus().insertContent('<p style="text-align: center;"></p>').run();
                  }
                }
              }
            }}
            disabled={mode === 'text'}
            title="CÄƒn giá»¯a"
          >
            <AlignCenter className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (mode === 'visual' && editor) {
                const { from, to } = editor.state.selection;
                const selectedContent = editor.state.doc.textBetween(from, to);
                if (selectedContent) {
                  editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: right;">${selectedContent}</p>`).run();
                } else {
                  const { $from } = editor.state.selection;
                  const paragraph = $from.node(-1);
                  if (paragraph && paragraph.type.name === 'paragraph') {
                    const paraText = paragraph.textContent;
                    const paraStart = $from.start(-1);
                    const paraEnd = $from.end(-1);
                    editor.chain().focus().setTextSelection({ from: paraStart, to: paraEnd }).deleteSelection().insertContent(`<p style="text-align: right;">${paraText}</p>`).run();
                  } else {
                    editor.chain().focus().insertContent('<p style="text-align: right;"></p>').run();
                  }
                }
              }
            }}
            disabled={mode === 'text'}
            title="CÄƒn pháº£i"
          >
            <AlignRight className="h-4 w-4" />
          </Button>

          <div className="h-6 w-px bg-border mx-1" />

          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={addLink}
            title="ChÃ¨n/Sá»­a liÃªn káº¿t"
          >
            <LinkIcon className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={insertReadMore}
            title="Tháº» Äá»c tiáº¿p"
          >
            <Type className="h-4 w-4" />
          </Button>

          <div className="flex-1" />

          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => setShowToolbarRow2(!showToolbarRow2)}
            title="Má»Ÿ rá»™ng thanh cÃ´ng cá»¥"
          >
            <MoreHorizontal className="h-4 w-4" />
          </Button>
        </div>

        {/* Row 2: Advanced Formatting (Toggle) */}
        {showToolbarRow2 && (
          <div className="flex items-center gap-1 p-2 border-b border-input">
            <Select
              defaultValue="paragraph"
              onValueChange={(value) => {
                if (mode === 'visual' && editor) {
                  if (value === 'paragraph') {
                    editor.chain().focus().setParagraph().run();
                  } else if (value.startsWith('heading')) {
                    const level = parseInt(value.replace('heading', '')) as 1 | 2 | 3 | 4 | 5 | 6;
                    editor.chain().focus().toggleHeading({ level }).run();
                  }
                }
              }}
              disabled={mode === 'text'}
            >
              <SelectTrigger className="w-40 h-8 text-xs">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="paragraph">Äoáº¡n vÄƒn</SelectItem>
                <SelectItem value="heading1">TiÃªu Ä‘á» 1</SelectItem>
                <SelectItem value="heading2">TiÃªu Ä‘á» 2</SelectItem>
                <SelectItem value="heading3">TiÃªu Ä‘á» 3</SelectItem>
                <SelectItem value="heading4">TiÃªu Ä‘á» 4</SelectItem>
                <SelectItem value="heading5">TiÃªu Ä‘á» 5</SelectItem>
                <SelectItem value="heading6">TiÃªu Ä‘á» 6</SelectItem>
              </SelectContent>
            </Select>

            <div className="h-6 w-px bg-border mx-1" />

            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                // Underline - wrap selected text in <u> tag
                if (editor) {
                  const { from, to } = editor.state.selection;
                  const selectedText = editor.state.doc.textBetween(from, to);
                  if (selectedText) {
                    // Delete selected text first, then insert wrapped version
                    editor.chain().focus().deleteSelection().insertContent(`<u>${selectedText}</u>`).run();
                  } else {
                    editor.chain().focus().insertContent('<u></u>').run();
                  }
                }
              }}
              title="Gáº¡ch chÃ¢n"
            >
              <UnderlineIcon className="h-4 w-4" />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (editor) {
                  const { from, to } = editor.state.selection;
                  const selectedContent = editor.state.doc.textBetween(from, to);
                  if (selectedContent) {
                    editor.chain().focus().deleteSelection().insertContent(`<p style="text-align: justify;">${selectedContent}</p>`).run();
                  } else {
                    const { $from } = editor.state.selection;
                    const paragraph = $from.node(-1);
                    if (paragraph && paragraph.type.name === 'paragraph') {
                      const paraText = paragraph.textContent;
                      const paraStart = $from.start(-1);
                      const paraEnd = $from.end(-1);
                      editor.chain().focus().setTextSelection({ from: paraStart, to: paraEnd }).deleteSelection().insertContent(`<p style="text-align: justify;">${paraText}</p>`).run();
                    } else {
                      editor.chain().focus().insertContent('<p style="text-align: justify;"></p>').run();
                    }
                  }
                }
              }}
              title="CÄƒn Ä‘á»u 2 bÃªn"
            >
              <AlignJustify className="h-4 w-4" />
            </Button>

            <div className="h-6 w-px bg-border mx-1" />

            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                const color = prompt('Nháº­p mÃ£ mÃ u (VD: #FF0000):');
                if (!color) return;
                
                // Validate color format
                const colorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
                if (!colorRegex.test(color) && !['red', 'blue', 'green', 'black', 'white'].includes(color.toLowerCase())) {
                  alert('MÃ£ mÃ u khÃ´ng há»£p lá»‡. Sá»­ dá»¥ng format #RRGGBB hoáº·c tÃªn mÃ u.');
                  return;
                }

                if (mode === 'visual' && editor) {
                  const { from, to } = editor.state.selection;
                  const selectedText = editor.state.doc.textBetween(from, to);
                  if (selectedText) {
                    editor.chain().focus().deleteSelection().insertContent(`<span style="color: ${color};">${selectedText}</span>`).run();
                  } else {
                    editor.chain().focus().insertContent(`<span style="color: ${color};">text</span>`).run();
                  }
                } else if (mode === 'text' && textareaRef.current) {
                  const textarea = textareaRef.current;
                  const start = textarea.selectionStart;
                  const end = textarea.selectionEnd;
                  const selectedText = textarea.value.substring(start, end);
                  const wrappedText = selectedText || 'text';
                  const newText = textarea.value.substring(0, start) + `<span style="color: ${color};">${wrappedText}</span>` + textarea.value.substring(end);
                  setTextContent(newText);
                  onChange(newText);
                  setTimeout(() => {
                    if (textareaRef.current) {
                      textareaRef.current.value = newText;
                      const newCursorPos = start + `<span style="color: ${color};">${wrappedText}</span>`.length;
                      textareaRef.current.setSelectionRange(newCursorPos, newCursorPos);
                      textareaRef.current.focus();
                    }
                  }, 0);
                }
              }}
              disabled={mode === 'text' && !textareaRef.current}
              title="MÃ u chá»¯"
            >
              <Palette className="h-4 w-4" />
            </Button>

            <div className="h-6 w-px bg-border mx-1" />

            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  // Clear formatting - remove all marks
                  editor.chain().focus().unsetBold().unsetItalic().unsetStrike().run();
                }
                // In text mode, clearing formatting is not straightforward, so disable
              }}
              disabled={mode === 'text' || !editor?.can().unsetBold()}
              title="Táº©y Ä‘á»‹nh dáº¡ng"
            >
              <Code className="h-4 w-4" />
            </Button>

            <div className="h-6 w-px bg-border mx-1" />

            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().undo().run();
                }
                // Undo/Redo in text mode would need custom implementation
              }}
              disabled={mode === 'text' || !editor?.can().undo()}
              title="HoÃ n tÃ¡c (Ctrl+Z)"
            >
              <Undo className="h-4 w-4" />
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (mode === 'visual' && editor) {
                  editor.chain().focus().redo().run();
                }
              }}
              disabled={mode === 'text' || !editor?.can().redo()}
              title="LÃ m láº¡i (Ctrl+Y)"
            >
              <Redo className="h-4 w-4" />
            </Button>
          </div>
        )}

        {/* Mode Toggle */}
        <div className="flex items-center justify-between p-2 bg-background">
          <div className="flex gap-1">
            <Button
              type="button"
              variant={mode === 'visual' ? 'default' : 'ghost'}
              size="sm"
              onClick={() => setMode('visual')}
              className="h-7"
            >
              <Eye className="h-3 w-3 mr-1" />
              Trá»±c quan
            </Button>
            <Button
              type="button"
              variant={mode === 'text' ? 'default' : 'ghost'}
              size="sm"
              onClick={() => setMode('text')}
              className="h-7"
            >
              <Code2 className="h-3 w-3 mr-1" />
              VÄƒn báº£n
            </Button>
          </div>
        </div>
      </div>

      {/* Editor Content */}
      {mode === 'visual' ? (
        <ImageEditorErrorBoundary>
          <div className="relative">
            <EditorContent editor={editor} />
            {editor && <InlineImageToolbar editor={editor} />}
          </div>
        </ImageEditorErrorBoundary>
      ) : (
        <div className="relative">
          {/* QuickTags Toolbar for Text Mode */}
          <div ref={toolbarRef} className="border-b border-input p-2 bg-muted flex gap-1 flex-wrap">
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => insertQuickTag('<strong>', '</strong>')}
              className="h-7 text-xs"
            >
              b
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => insertQuickTag('<em>', '</em>')}
              className="h-7 text-xs"
            >
              i
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => insertQuickTag('<del>', '</del>')}
              className="h-7 text-xs"
            >
              del
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => insertQuickTag('<code>', '</code>')}
              className="h-7 text-xs"
            >
              code
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={addLink}
              className="h-7 text-xs"
            >
              link
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={addImage}
              className="h-7 text-xs"
            >
              img
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (!textareaRef.current) return;
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = textarea.value.substring(start, end);
                
                if (selectedText) {
                  // Wrap each line in <li>
                  const lines = selectedText.split('\n').filter(l => l.trim());
                  const listItems = lines.map(line => `<li>${line}</li>`).join('\n');
                  const newText =
                    textarea.value.substring(0, start) +
                    `<ul>\n${listItems}\n</ul>` +
                    textarea.value.substring(end);
                  setTextContent(newText);
                  onChange(newText);
                  textarea.value = newText;
                  textarea.focus();
                } else {
                  insertQuickTag('<ul>\n<li>', '</li>\n</ul>');
                }
              }}
              className="h-7 text-xs"
            >
              ul
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => {
                if (!textareaRef.current) return;
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = textarea.value.substring(start, end);
                
                if (selectedText) {
                  // Wrap each line in <li>
                  const lines = selectedText.split('\n').filter(l => l.trim());
                  const listItems = lines.map(line => `<li>${line}</li>`).join('\n');
                  const newText =
                    textarea.value.substring(0, start) +
                    `<ol>\n${listItems}\n</ol>` +
                    textarea.value.substring(end);
                  setTextContent(newText);
                  onChange(newText);
                  textarea.value = newText;
                  textarea.focus();
                } else {
                  insertQuickTag('<ol>\n<li>', '</li>\n</ol>');
                }
              }}
              className="h-7 text-xs"
            >
              ol
            </Button>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => insertQuickTag('<blockquote>', '</blockquote>')}
              className="h-7 text-xs"
            >
              quote
            </Button>
          </div>
          <Textarea
            ref={textareaRef}
            value={textContent}
            onChange={handleTextChange}
            className="min-h-[300px] font-mono text-sm rounded-none border-0 focus-visible:ring-0"
            placeholder="Nháº­p HTML hoáº·c vÄƒn báº£n..."
          />
        </div>
      )}

      {/* Media Library Modal */}
      <MediaLibraryModal
        isOpen={showMediaModal}
        onClose={() => setShowMediaModal(false)}
        onInsert={(html) => {
          if (!html) return;
          if (mode === 'visual' && editor) {
            // Check if we're inserting a video embed wrapper
            if (html.includes('video-embed-wrapper')) {
              // Parse the HTML to extract wrapper and iframe
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = html;
              const wrapper = tempDiv.querySelector('div.video-embed-wrapper');
              const iframe = wrapper?.querySelector('iframe');
              
              if (wrapper && iframe) {
                // Extract attributes
                const wrapperStyle = wrapper.getAttribute('style') || '';
                const wrapperClass = wrapper.getAttribute('class') || 'video-embed-wrapper';
                const iframeAttrs = {
                  src: iframe.getAttribute('src') || '',
                  frameborder: iframe.getAttribute('frameborder') || '0',
                  allowfullscreen: iframe.hasAttribute('allowfullscreen'),
                  allow: iframe.getAttribute('allow') || '',
                  style: iframe.getAttribute('style') || '',
                  class: iframe.getAttribute('class') || '',
                  width: iframe.getAttribute('width') || '100%',
                  height: iframe.getAttribute('height') || '400px',
                };
                
                try {
                  // Insert as proper node structure to avoid paragraph wrapping
                  editor.chain()
                    .focus()
                    .insertContent({
                      type: 'videoEmbedWrapper',
                      attrs: {
                        style: wrapperStyle,
                        class: wrapperClass,
                      },
                      content: [
                        {
                          type: 'iframe',
                          attrs: iframeAttrs,
                        },
                      ],
                    })
                    .run();
                } catch (error) {
                  // Fallback to raw HTML insert
                  editor.chain().focus().insertContent(html).run();
                }
              } else {
                // Fallback to raw HTML insert
                editor.chain().focus().insertContent(html).run();
              }
            } else {
              // Insert HTML into Tiptap editor
              editor.chain().focus().insertContent(html).run();
            }
            
            // Update textContent for sync
            const newHtml = editor.getHTML();
            
            // Check if video embed wrapper exists in DOM
            const editorElement = editor.view.dom;
            setTextContent(newHtml);
            onChange(newHtml);
          } else {
            // Insert into textarea
            if (textareaRef.current) {
              const textarea = textareaRef.current;
              const start = textarea.selectionStart;
              const newText =
                textarea.value.substring(0, start) + html + textarea.value.substring(start);
              setTextContent(newText);
              onChange(newText);
              
              // Update textarea and set cursor position
              setTimeout(() => {
                if (textareaRef.current) {
                  textareaRef.current.value = newText;
                  const newCursorPos = start + html.length;
                  textareaRef.current.setSelectionRange(newCursorPos, newCursorPos);
                  textareaRef.current.focus();
                }
              }, 0);
            }
          }
        }}
      />
    </div>
  );
}



--- FILE: components/admin/products/ProductDataMetaBox/GeneralTab.tsx ---


'use client';

import { useState, useMemo, useEffect } from 'react';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { DollarSign, TrendingUp, Percent, Calendar, Upload, X, File } from 'lucide-react';
import type { ProductDataMetaBoxState } from './ProductDataMetaBox';
import { DownloadableFilesSection } from './DownloadableFilesSection';
import { PriceInput } from '../PriceInput';

interface GeneralTabProps {
  state: ProductDataMetaBoxState;
  onUpdate: (updates: Partial<ProductDataMetaBoxState>) => void;
}

/**
 * General Tab - Pricing and Downloadable Files
 * Features:
 * - Cost Price (optional, admin only)
 * - Regular Price vá»›i real-time profit calculation
 * - Sale Price vá»›i schedule dates vÃ  discount %
 * - Downloadable Files section (conditional)
 */
export function GeneralTab({ state, onUpdate }: GeneralTabProps) {
  const [showSchedule, setShowSchedule] = useState(
    !!(state.salePriceStartDate || state.salePriceEndDate)
  );

  // Validate salePrice < regularPrice on mount/update
  useEffect(() => {
    if (state.salePrice !== undefined && state.regularPrice !== undefined && state.salePrice >= state.regularPrice) {
      // Auto-fix: clear invalid salePrice
      onUpdate({ salePrice: undefined });
    }
  }, [state.salePrice, state.regularPrice, onUpdate]);

  // Calculate profit in real-time
  const profit = useMemo(() => {
    if (!state.regularPrice || !state.costPrice) return null;
    const profitAmount = state.regularPrice - state.costPrice;
    const profitPercent = state.costPrice > 0 
      ? ((profitAmount / state.costPrice) * 100).toFixed(1)
      : '0';
    return { amount: profitAmount, percent: profitPercent };
  }, [state.regularPrice, state.costPrice]);

  // Calculate discount percentage
  const discountPercent = useMemo(() => {
    if (!state.salePrice || !state.regularPrice) return null;
    const discount = ((state.regularPrice - state.salePrice) / state.regularPrice) * 100;
    return discount.toFixed(1);
  }, [state.salePrice, state.regularPrice]);

  // Check if sale price should be active (date range check)
  const isSaleActive = useMemo(() => {
    if (!state.salePrice || !showSchedule) return true; // Always active if no schedule
    const now = new Date();
    const start = state.salePriceStartDate ? new Date(state.salePriceStartDate) : null;
    const end = state.salePriceEndDate ? new Date(state.salePriceEndDate) : null;
    
    if (start && now < start) return false;
    if (end && now > end) return false;
    return true;
  }, [state.salePrice, state.salePriceStartDate, state.salePriceEndDate, showSchedule]);

  // Format currency
  const formatCurrency = (value: number | undefined) => {
    if (value === undefined || value === null) return '';
    return new Intl.NumberFormat('vi-VN').format(value);
  };


  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-semibold mb-1">GiÃ¡ sáº£n pháº©m</h3>
        <p className="text-sm text-muted-foreground mb-6">
          Thiáº¿t láº­p giÃ¡ vá»‘n, giÃ¡ bÃ¡n vÃ  giÃ¡ khuyáº¿n mÃ£i cho sáº£n pháº©m
        </p>
      </div>

      {/* Cost Price */}
      <div className="space-y-2">
        <Label htmlFor="cost-price" className="text-sm font-medium flex items-center gap-2">
          <DollarSign className="h-4 w-4 text-muted-foreground" />
          GiÃ¡ vá»‘n
          <span className="text-xs text-muted-foreground font-normal">(TÃ¹y chá»n)</span>
        </Label>
        <PriceInput
          id="cost-price"
          placeholder="0"
          value={state.costPrice}
          onChange={(value) => onUpdate({ costPrice: value })}
        />
        <p className="text-xs text-muted-foreground">
          GiÃ¡ vá»‘n dÃ¹ng Ä‘á»ƒ tÃ­nh toÃ¡n lá»£i nhuáº­n. Chá»‰ hiá»ƒn thá»‹ cho admin.
        </p>
      </div>

      {/* Regular Price */}
      <div className="space-y-2">
        <Label htmlFor="regular-price" className="text-sm font-medium flex items-center gap-2">
          <DollarSign className="h-4 w-4 text-muted-foreground" />
          GiÃ¡ bÃ¡n thÆ°á»ng
          <span className="text-red-500">*</span>
        </Label>
        <PriceInput
          id="regular-price"
          placeholder="0"
          required
          value={state.regularPrice}
          onChange={(value) => onUpdate({ regularPrice: value })}
        />
        {/* Real-time Profit Calculation */}
        {profit && state.costPrice && (
          <div className="flex items-center gap-2 text-sm">
            <TrendingUp className="h-4 w-4 text-green-600" />
            <span className="text-green-600 font-medium">
              LÃ£i: {formatCurrency(profit.amount)}Ä‘ ({profit.percent}%)
            </span>
          </div>
        )}
      </div>

      {/* Sale Price */}
      <div className="space-y-3 p-4 border border-input rounded-lg bg-muted/30">
        <div className="space-y-2">
          <Label htmlFor="sale-price" className="text-sm font-medium flex items-center gap-2">
            <Percent className="h-4 w-4 text-muted-foreground" />
            GiÃ¡ khuyáº¿n mÃ£i
            <span className="text-xs text-muted-foreground font-normal">(TÃ¹y chá»n)</span>
          </Label>
          <PriceInput
            id="sale-price"
            placeholder="0"
            value={state.salePrice}
            onChange={(value) => {
              // Validate: salePrice must be less than regularPrice
              if (value !== undefined && state.regularPrice && value >= state.regularPrice) {
                return; // Don't update if invalid
              }
              onUpdate({ salePrice: value });
            }}
            disabled={!state.regularPrice}
          />
          {state.salePrice && state.regularPrice && discountPercent && (
            <div className="flex items-center gap-2 text-sm">
              <Percent className="h-4 w-4 text-orange-600" />
              <span className="text-orange-600 font-medium">
                Äang giáº£m {discountPercent}%
              </span>
            </div>
          )}
          {state.salePrice && state.regularPrice && state.salePrice >= state.regularPrice && (
            <p className="text-xs text-red-500">
              GiÃ¡ khuyáº¿n mÃ£i pháº£i nhá» hÆ¡n giÃ¡ bÃ¡n thÆ°á»ng
            </p>
          )}
        </div>

        {/* Schedule Checkbox */}
        <label className="flex items-center gap-2 cursor-pointer group">
          <Checkbox
            id="schedule-sale"
            checked={showSchedule}
            onCheckedChange={(checked) => {
              setShowSchedule(checked === true);
              if (!checked) {
                onUpdate({ salePriceStartDate: undefined, salePriceEndDate: undefined });
              }
            }}
          />
          <span className="text-sm text-foreground group-hover:text-primary transition-colors flex items-center gap-2">
            <Calendar className="h-4 w-4" />
            LÃªn lá»‹ch khuyáº¿n mÃ£i
          </span>
        </label>

        {/* Schedule Date Pickers */}
        {showSchedule && (
          <div className="grid grid-cols-2 gap-4 pt-2 border-t border-input">
            <div className="space-y-2">
              <Label htmlFor="sale-start-date" className="text-xs">
                NgÃ y báº¯t Ä‘áº§u
              </Label>
              <Input
                id="sale-start-date"
                type="datetime-local"
                value={state.salePriceStartDate || ''}
                onChange={(e) => onUpdate({ salePriceStartDate: e.target.value || undefined })}
                className="text-sm"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="sale-end-date" className="text-xs">
                NgÃ y káº¿t thÃºc
              </Label>
              <Input
                id="sale-end-date"
                type="datetime-local"
                value={state.salePriceEndDate || ''}
                onChange={(e) => onUpdate({ salePriceEndDate: e.target.value || undefined })}
                className="text-sm"
              />
            </div>
            {!isSaleActive && state.salePrice && (
              <div className="col-span-2 text-xs text-muted-foreground bg-yellow-50 dark:bg-yellow-900/20 p-2 rounded">
                âš ï¸ GiÃ¡ khuyáº¿n mÃ£i hiá»‡n khÃ´ng hoáº¡t Ä‘á»™ng (ngoÃ i khoáº£ng thá»i gian Ä‘Ã£ lÃªn lá»‹ch)
              </div>
            )}
          </div>
        )}
      </div>

      {/* Downloadable Files Section */}
      {state.isDownloadable && (
        <div className="pt-6 border-t border-input">
          <DownloadableFilesSection
            files={state.downloadableFiles || []}
            onFilesChange={(files) => onUpdate({ downloadableFiles: files })}
          />
        </div>
      )}
    </div>
  );
}



--- FILE: components/admin/products/ProductDataMetaBox/ShippingTab.tsx ---


'use client';

import { useState } from 'react';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Package, Ruler, Truck } from 'lucide-react';
import type { ProductDataMetaBoxState } from './ProductDataMetaBox';

interface ShippingTabProps {
  state: ProductDataMetaBoxState;
  onUpdate: (updates: Partial<ProductDataMetaBoxState>) => void;
}

/**
 * Shipping Tab - Weight, Dimensions, Shipping Class
 * Features:
 * - Weight field vá»›i unit selector (kg/g)
 * - Dimensions fields (Length, Width, Height) vá»›i unit selector (cm/m)
 * - Shipping Class dropdown
 * Note: Tab nÃ y sáº½ tá»± Ä‘á»™ng áº©n khi isVirtual = true
 */
export function ShippingTab({ state, onUpdate }: ShippingTabProps) {
  const [weightUnit, setWeightUnit] = useState<'kg' | 'g'>('kg');
  const [dimensionUnit, setDimensionUnit] = useState<'cm' | 'm'>('cm');

  // Shipping class options
  // Note: Cannot use empty string for SelectItem value (Radix UI restriction)
  // Use '__none__' as special value for "no shipping class"
  const shippingClasses = [
    { value: '__none__', label: 'KhÃ´ng cÃ³' },
    { value: 'standard', label: 'HÃ ng thÆ°á»ng' },
    { value: 'fragile', label: 'HÃ ng dá»… vá»¡' },
    { value: 'bulky', label: 'HÃ ng cá»“ng ká»nh' },
    { value: 'express', label: 'Giao hÃ ng nhanh' },
  ];

  // Handle weight change with unit conversion
  const handleWeightChange = (value: string) => {
    const numValue = value === '' ? undefined : parseFloat(value);
    if (numValue !== undefined && numValue < 0) return;
    onUpdate({ weight: numValue });
  };

  // Handle dimension change
  const handleDimensionChange = (field: 'length' | 'width' | 'height', value: string) => {
    const numValue = value === '' ? undefined : parseFloat(value);
    if (numValue !== undefined && numValue < 0) return;
    onUpdate({ [field]: numValue });
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-semibold mb-1">Giao hÃ ng</h3>
        <p className="text-sm text-muted-foreground mb-6">
          Thiáº¿t láº­p thÃ´ng tin váº­n chuyá»ƒn Ä‘á»ƒ tÃ­nh phÃ­ giao hÃ ng chÃ­nh xÃ¡c
        </p>
      </div>

      {/* Weight Field */}
      <div className="space-y-2">
        <Label htmlFor="weight" className="text-sm font-medium flex items-center gap-2">
          <Package className="h-4 w-4 text-muted-foreground" />
          Trá»ng lÆ°á»£ng
        </Label>
        <div className="flex items-center gap-2">
          <div className="relative flex-1">
            <Input
              id="weight"
              type="number"
              step="0.1"
              min="0"
              placeholder="0"
              value={state.weight || ''}
              onChange={(e) => handleWeightChange(e.target.value)}
              className="pr-16"
            />
            <div className="absolute right-3 top-1/2 -translate-y-1/2 flex items-center gap-1">
              <Select
                value={weightUnit}
                onValueChange={(value) => setWeightUnit(value as 'kg' | 'g')}
              >
                <SelectTrigger className="w-12 h-6 text-xs border-0 bg-transparent p-0 focus:ring-0">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="kg">kg</SelectItem>
                  <SelectItem value="g">g</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
        <p className="text-xs text-muted-foreground">
          Trá»ng lÆ°á»£ng sáº£n pháº©m dÃ¹ng Ä‘á»ƒ tÃ­nh phÃ­ váº­n chuyá»ƒn
        </p>
      </div>

      {/* Dimensions Fields */}
      <div className="space-y-3 p-4 border border-input rounded-lg bg-muted/30">
        <Label className="text-sm font-semibold flex items-center gap-2">
          <Ruler className="h-4 w-4 text-muted-foreground" />
          KÃ­ch thÆ°á»›c
        </Label>
        <div className="flex items-center gap-2 mb-3">
          <span className="text-xs text-muted-foreground">ÄÆ¡n vá»‹:</span>
          <Select
            value={dimensionUnit}
            onValueChange={(value) => setDimensionUnit(value as 'cm' | 'm')}
          >
            <SelectTrigger className="w-20 h-8 text-xs">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="cm">cm</SelectItem>
              <SelectItem value="m">m</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <div className="grid grid-cols-3 gap-3">
          {/* Length */}
          <div className="space-y-2">
            <Label htmlFor="length" className="text-xs font-medium">
              DÃ i ({dimensionUnit})
            </Label>
            <Input
              id="length"
              type="number"
              step="0.1"
              min="0"
              placeholder="0"
              value={state.length || ''}
              onChange={(e) => handleDimensionChange('length', e.target.value)}
              className="text-sm"
            />
          </div>

          {/* Width */}
          <div className="space-y-2">
            <Label htmlFor="width" className="text-xs font-medium">
              Rá»™ng ({dimensionUnit})
            </Label>
            <Input
              id="width"
              type="number"
              step="0.1"
              min="0"
              placeholder="0"
              value={state.width || ''}
              onChange={(e) => handleDimensionChange('width', e.target.value)}
              className="text-sm"
            />
          </div>

          {/* Height */}
          <div className="space-y-2">
            <Label htmlFor="height" className="text-xs font-medium">
              Cao ({dimensionUnit})
            </Label>
            <Input
              id="height"
              type="number"
              step="0.1"
              min="0"
              placeholder="0"
              value={state.height || ''}
              onChange={(e) => handleDimensionChange('height', e.target.value)}
              className="text-sm"
            />
          </div>
        </div>
        <p className="text-xs text-muted-foreground">
          KÃ­ch thÆ°á»›c sáº£n pháº©m (DÃ i x Rá»™ng x Cao) dÃ¹ng Ä‘á»ƒ tÃ­nh phÃ­ váº­n chuyá»ƒn
        </p>
      </div>

      {/* Shipping Class */}
      <div className="space-y-2">
        <Label htmlFor="shipping-class" className="text-sm font-medium flex items-center gap-2">
          <Truck className="h-4 w-4 text-muted-foreground" />
          Lá»›p giao hÃ ng
        </Label>
        <Select
          value={state.shippingClass || '__none__'}
          onValueChange={(value) => {
            // Convert '__none__' to undefined when saving
            onUpdate({ shippingClass: value === '__none__' ? undefined : value });
          }}
        >
          <SelectTrigger id="shipping-class" className="w-full">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {shippingClasses.map((option) => (
              <SelectItem key={option.value} value={option.value}>
                {option.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <p className="text-xs text-muted-foreground">
          Chá»n lá»›p giao hÃ ng phÃ¹ há»£p Ä‘á»ƒ tÃ­nh phÃ­ váº­n chuyá»ƒn chÃ­nh xÃ¡c. VÃ­ dá»¥: HÃ ng dá»… vá»¡ cÃ³ thá»ƒ cÃ³ phÃ­ báº£o hiá»ƒm cao hÆ¡n.
        </p>
      </div>

      {/* Info Box */}
      <div className="p-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg">
        <p className="text-sm text-blue-900 dark:text-blue-200">
          <strong>LÆ°u Ã½:</strong> ThÃ´ng tin trá»ng lÆ°á»£ng vÃ  kÃ­ch thÆ°á»›c sáº½ Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘á»ƒ tÃ­nh phÃ­ váº­n chuyá»ƒn tá»± Ä‘á»™ng thÃ´ng qua cÃ¡c API váº­n chuyá»ƒn (Giao HÃ ng Nhanh, Viettel Post, v.v.)
        </p>
      </div>
    </div>
  );
}



--- FILE: components/admin/products/sidebar/FeaturedImageBox.tsx ---


'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Image as ImageIcon } from 'lucide-react';
import { MediaPicker } from '@/components/admin/media/MediaPicker';
import type { MediaPickerValue } from '@/components/admin/media/MediaPicker';

interface FeaturedImageBoxProps {
  thumbnailId?: string; // Attachment ID
  thumbnailUrl?: string; // Thumbnail URL for display
  altText?: string; // Alt text for SEO
  onImageChange: (attachmentId: string, thumbnailUrl: string) => void;
  onImageRemove: () => void;
  onAltTextChange?: (altText: string) => void; // Callback for alt text changes
}

/**
 * Featured Image Box - Sidebar component cho featured image management
 * Features:
 * - 2 states: Empty / Has image
 * - Uses MediaPicker for media selection
 * - Save attachment_id to hidden input _thumbnail_id
 * - Remove button
 * - Thumbnail display (260px width)
 */
export function FeaturedImageBox({
  thumbnailId,
  thumbnailUrl,
  altText = '',
  onImageChange,
  onImageRemove,
  onAltTextChange,
}: FeaturedImageBoxProps) {
  const [mediaValue, setMediaValue] = useState<MediaPickerValue | undefined>();

  // Sync with props
  useEffect(() => {
    if (thumbnailId && thumbnailUrl) {
      setMediaValue({
        _id: thumbnailId,
        url: thumbnailUrl,
        name: 'Featured Image',
        type: 'image',
        thumbnail_url: thumbnailUrl,
      });
    } else {
      setMediaValue(undefined);
    }
  }, [thumbnailId, thumbnailUrl]);

  const handleChange = (value: MediaPickerValue | MediaPickerValue[] | undefined) => {
    if (!value) {
      setMediaValue(undefined);
      onImageRemove();
      return;
    }

    const selected = Array.isArray(value) ? value[0] : value;
    setMediaValue(selected);
    onImageChange(selected._id, selected.thumbnail_url || selected.url);
  };

  const hasImage = !!mediaValue;

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-base flex items-center gap-2">
          <ImageIcon className="h-4 w-4" />
          HÃ¬nh áº£nh Ä‘áº¡i diá»‡n
        </CardTitle>
      </CardHeader>
      <CardContent>
        {/* Hidden input for _thumbnail_id */}
        <input
          type="hidden"
          name="_thumbnail_id"
          value={thumbnailId || ''}
        />

        {/* MediaPicker */}
        <MediaPicker
          value={mediaValue}
          onChange={handleChange}
          multiple={false}
          type="image"
        />

        {/* Alt Text Input - Only show when image is selected */}
        {thumbnailId && (
          <div className="mt-4 space-y-2">
            <Label htmlFor="featured-image-alt" className="text-xs font-medium">
              VÄƒn báº£n thay tháº¿ (Alt Text) cho SEO
            </Label>
            <Input
              id="featured-image-alt"
              type="text"
              placeholder="MÃ´ táº£ hÃ¬nh áº£nh cho SEO (vÃ­ dá»¥: Gáº¥u bÃ´ng Teddy mÃ u nÃ¢u)"
              value={altText}
              onChange={(e) => onAltTextChange?.(e.target.value)}
              className="text-sm"
            />
            <p className="text-xs text-muted-foreground">
              Alt text giÃºp cáº£i thiá»‡n SEO vÃ  kháº£ nÄƒng tiáº¿p cáº­n cho ngÆ°á»i dÃ¹ng khiáº¿m thá»‹
            </p>
          </div>
        )}
      </CardContent>
    </Card>
  );
}



--- FILE: components/admin/products/sidebar/ProductGalleryBox.tsx ---


'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Image as ImageIcon, X, GripVertical } from 'lucide-react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { MediaLibraryModal, type MediaItem } from '../MediaLibraryModal';

interface GalleryImage {
  id: string; // Attachment ID
  thumbnail_url: string; // Thumbnail URL for display
  title?: string; // Image title for tooltip
  altText?: string; // Alt text for SEO
}

interface ProductGalleryBoxProps {
  galleryImages?: GalleryImage[]; // Array of {id, thumbnail_url, title, altText}
  onImagesChange: (images: GalleryImage[]) => void;
  onAltTextChange?: (imageId: string, altText: string) => void; // Callback for alt text changes
}

/**
 * Sortable Gallery Item Component
 */
function SortableGalleryItem({ 
  image, 
  onRemove 
}: { 
  image: GalleryImage; 
  onRemove: () => void;
}) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: image.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={{ ...style, width: '80px', height: '80px' }}
      className="relative group rounded-lg overflow-hidden border-2 border-muted cursor-move"
      title={image.title || `Image ${image.id}`}
    >
      <img
        src={image.thumbnail_url}
        alt={image.title || `Gallery ${image.id}`}
        className="w-full h-full object-cover"
        loading={image.id ? 'lazy' : 'eager'} // Lazy load for better performance
        onError={() => {
          console.error(`Failed to load gallery image: ${image.id}`);
        }}
      />

      {/* Overlay on hover */}
      <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2">
        {/* Drag handle */}
        <div
          {...attributes}
          {...listeners}
          className="text-white cursor-grab active:cursor-grabbing"
        >
          <GripVertical className="h-5 w-5" />
        </div>

        {/* Quick Remove Button */}
        <Button
          type="button"
          variant="destructive"
          size="sm"
          onClick={(e) => {
            e.stopPropagation();
            onRemove();
          }}
          className="h-8"
        >
          <X className="h-3 w-3" />
        </Button>
      </div>
    </div>
  );
}

/**
 * Product Gallery Box - Sidebar component cho product gallery management
 * Features:
 * - Grid layout vá»›i thumbnails 80x80px
 * - Multi-select trong Media Modal
 * - Drag & Drop Ä‘á»ƒ sáº¯p xáº¿p
 * - Quick remove button (hover)
 * - Tooltip vá»›i tÃªn file
 * - Hidden input _product_image_gallery (comma-separated IDs)
 * - Append mode (khÃ´ng ghi Ä‘Ã¨)
 * - Lazy loading (> 20 áº£nh)
 */
export function ProductGalleryBox({
  galleryImages = [],
  onImagesChange,
  onAltTextChange,
}: ProductGalleryBoxProps) {
  const [showMediaModal, setShowMediaModal] = useState(false);
  const [images, setImages] = useState<GalleryImage[]>(galleryImages);

  // Sync with prop changes
  useEffect(() => {
    setImages(galleryImages);
  }, [galleryImages]);

  // Drag & Drop sensors
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setImages((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        const newItems = arrayMove(items, oldIndex, newIndex);
        onImagesChange(newItems);
        return newItems;
      });
    }
  };

  const handleMediaSelect = (items: MediaItem | MediaItem[]) => {
    // In multiple mode, onSelect returns an array
    const selectedItems = Array.isArray(items) ? items : [items];
    
    // Convert to GalleryImage format
    const newGalleryImages: GalleryImage[] = selectedItems.map((item) => ({
      id: item.id,
      thumbnail_url: item.thumbnail_url || item.url,
      title: item.title,
    }));

    // Append mode: add to existing images (don't overwrite)
    const updatedImages = [...images, ...newGalleryImages];
    setImages(updatedImages);
    onImagesChange(updatedImages);
    setShowMediaModal(false);
  };

  const handleRemove = (imageId: string) => {
    // Optimistic UI: remove immediately
    const newImages = images.filter((img) => img.id !== imageId);
    setImages(newImages);
    onImagesChange(newImages);
  };

  // Generate comma-separated IDs string for hidden input
  const galleryIdsString = images.map((img) => img.id).join(',');

  // Use lazy loading for thumbnails if > 20 images
  const useLazyLoading = images.length > 20;

  return (
    <>
      <Card>
        <CardHeader>
          <CardTitle className="text-base flex items-center gap-2">
            <ImageIcon className="h-4 w-4" />
            ThÆ° viá»‡n hÃ¬nh áº£nh
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Hidden input for _product_image_gallery */}
          <input
            type="hidden"
            name="_product_image_gallery"
            value={galleryIdsString}
          />

          {/* Gallery Grid */}
          {images.length > 0 ? (
            <DndContext
              sensors={sensors}
              collisionDetection={closestCenter}
              onDragEnd={handleDragEnd}
            >
              <SortableContext
                items={images.map((img) => img.id)}
              >
                <div className="grid grid-cols-3 gap-2" style={{ gridAutoRows: '80px' }}>
                  {images.map((image) => (
                    <SortableGalleryItem
                      key={image.id}
                      image={image}
                      onRemove={() => handleRemove(image.id)}
                    />
                  ))}
                </div>
              </SortableContext>
            </DndContext>
          ) : (
            <div 
              className="rounded-lg border-2 border-dashed border-muted flex items-center justify-center bg-muted/50"
              style={{ width: '80px', height: '80px' }}
            >
              <div className="text-center">
                <ImageIcon className="h-6 w-6 mx-auto text-muted-foreground mb-1" />
                <p className="text-xs text-muted-foreground">ChÆ°a cÃ³</p>
              </div>
            </div>
          )}

          {/* Add Gallery Images Button */}
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={() => setShowMediaModal(true)}
            className="w-full"
          >
            <ImageIcon className="h-4 w-4 mr-2" />
            ThÃªm áº£nh thÆ° viá»‡n sáº£n pháº©m
          </Button>

          {/* Info */}
          {images.length > 0 && (
            <p className="text-xs text-muted-foreground">
              {images.length} hÃ¬nh áº£nh â€¢ KÃ©o tháº£ Ä‘á»ƒ sáº¯p xáº¿p
            </p>
          )}

          {/* Alt Text Inputs for Gallery Images */}
          {images.length > 0 && (
            <div className="mt-4 space-y-3 pt-4 border-t">
              <Label className="text-xs font-medium">
                VÄƒn báº£n thay tháº¿ (Alt Text) cho SEO
              </Label>
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {images.map((image) => (
                  <div key={image.id} className="flex gap-2 items-center">
                    <div className="w-12 h-12 flex-shrink-0 rounded overflow-hidden border">
                      <img
                        src={image.thumbnail_url}
                        alt={image.altText || `Gallery ${image.id}`}
                        className="w-full h-full object-cover"
                      />
                    </div>
                    <Input
                      type="text"
                      placeholder="Nháº­p alt text cho hÃ¬nh áº£nh nÃ y"
                      value={image.altText || ''}
                      onChange={(e) => {
                        const updatedImages = images.map((img) =>
                          img.id === image.id
                            ? { ...img, altText: e.target.value }
                            : img
                        );
                        setImages(updatedImages);
                        onImagesChange(updatedImages);
                        onAltTextChange?.(image.id, e.target.value);
                      }}
                      className="text-xs flex-1"
                    />
                  </div>
                ))}
              </div>
              <p className="text-xs text-muted-foreground">
                Alt text giÃºp cáº£i thiá»‡n SEO vÃ  kháº£ nÄƒng tiáº¿p cáº­n
              </p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Media Library Modal */}
      <MediaLibraryModal
        isOpen={showMediaModal}
        onClose={() => setShowMediaModal(false)}
        onSelect={handleMediaSelect}
        mode="multiple"
        selectedIds={images.map((img) => img.id)}
        buttonText="ThÃªm vÃ o thÆ° viá»‡n"
      />
    </>
  );
}



--- FILE: components/admin/products/ProductActionMenu.tsx ---


'use client';

import { useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { MoreHorizontal, Eye, Copy, Trash2, RotateCcw, AlertTriangle, Loader2 } from 'lucide-react';
import type { MappedProduct } from '@/lib/utils/productMapper';
import { useToastContext } from '@/components/providers/ToastProvider';
import { RestoreProductModal } from './RestoreProductModal';
import { ForceDeleteModal } from './ForceDeleteModal';

interface ProductActionMenuProps {
  product: MappedProduct;
  isTrashTab?: boolean;
  isDeleting?: boolean;
  onDelete?: (id: string) => Promise<void>;
  onRestore?: (id: string) => Promise<void>;
  onForceDelete?: (id: string) => Promise<void>;
  onDuplicate?: (id: string) => Promise<void>;
}

export function ProductActionMenu({
  product,
  isTrashTab = false,
  onDelete,
  onRestore,
  onForceDelete,
  onDuplicate,
}: ProductActionMenuProps) {
  const router = useRouter();
  const { showToast } = useToastContext();
  const [isLoading, setIsLoading] = useState(false);
  const [showRestoreModal, setShowRestoreModal] = useState(false);
  const [showForceDeleteModal, setShowForceDeleteModal] = useState(false);

  const handleDelete = async () => {
    if (!onDelete) return;
    
    if (!confirm('Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a sáº£n pháº©m nÃ y?')) {
      return;
    }

    setIsLoading(true);
    try {
      await onDelete(product.id);
      showToast('ÄÃ£ chuyá»ƒn vÃ o thÃ¹ng rÃ¡c', 'success');
    } catch (error) {
      showToast('KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m', 'error');
    } finally {
      setIsLoading(false);
    }
  };

  const handleRestore = async () => {
    if (!onRestore) return;

    setIsLoading(true);
    try {
      await onRestore(product.id);
      showToast('ÄÃ£ khÃ´i phá»¥c sáº£n pháº©m', 'success');
      setShowRestoreModal(false);
    } catch (error) {
      showToast('KhÃ´ng thá»ƒ khÃ´i phá»¥c sáº£n pháº©m', 'error');
    } finally {
      setIsLoading(false);
    }
  };

  const handleForceDelete = async () => {
    if (!onForceDelete) return;

    setIsLoading(true);
    try {
      await onForceDelete(product.id);
      showToast('ÄÃ£ xÃ³a vÄ©nh viá»…n sáº£n pháº©m', 'success');
      setShowForceDeleteModal(false);
    } catch (error) {
      showToast('KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m', 'error');
    } finally {
      setIsLoading(false);
    }
  };

  const handleDuplicate = async () => {
    if (!onDuplicate) return;

    setIsLoading(true);
    try {
      await onDuplicate(product.id);
      showToast('ÄÃ£ táº¡o báº£n sao sáº£n pháº©m', 'success');
    } catch (error) {
      showToast('KhÃ´ng thá»ƒ táº¡o báº£n sao', 'error');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          className="h-8 w-8 p-0"
          disabled={isLoading}
        >
          <MoreHorizontal className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        {!isTrashTab && (
          <>
            <DropdownMenuItem asChild>
              <Link href={`/admin/products/${product.id}`} className="cursor-pointer">
                <Eye className="mr-2 h-4 w-4" />
                Xem chi tiáº¿t
              </Link>
            </DropdownMenuItem>
            <DropdownMenuItem asChild>
              <Link href={`/admin/products/${product.id}/edit`} className="cursor-pointer">
                <Eye className="mr-2 h-4 w-4" />
                Chá»‰nh sá»­a
              </Link>
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={handleDuplicate}
              disabled={isLoading}
              className="cursor-pointer"
            >
              <Copy className="mr-2 h-4 w-4" />
              NhÃ¢n báº£n
            </DropdownMenuItem>
            <DropdownMenuSeparator />
            <DropdownMenuItem
              onClick={handleDelete}
              disabled={isLoading}
              className="cursor-pointer text-red-600"
            >
              {isLoading ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : (
                <Trash2 className="mr-2 h-4 w-4" />
              )}
              {isLoading ? 'Äang xÃ³a...' : 'XÃ³a táº¡m'}
            </DropdownMenuItem>
          </>
        )}
        {isTrashTab && (
          <>
            <DropdownMenuItem
              onClick={() => setShowRestoreModal(true)}
              disabled={isLoading}
              className="cursor-pointer"
            >
              {isLoading ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : (
                <RotateCcw className="mr-2 h-4 w-4" />
              )}
              {isLoading ? 'Äang xá»­ lÃ½...' : 'KhÃ´i phá»¥c'}
            </DropdownMenuItem>
            <DropdownMenuSeparator />
            <DropdownMenuItem
              onClick={() => setShowForceDeleteModal(true)}
              disabled={isLoading}
              className="cursor-pointer text-red-600"
            >
              {isLoading ? (
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              ) : (
                <AlertTriangle className="mr-2 h-4 w-4" />
              )}
              {isLoading ? 'Äang xÃ³a...' : 'XÃ³a vÄ©nh viá»…n'}
            </DropdownMenuItem>
          </>
        )}
      </DropdownMenuContent>

      {/* Modals */}
      <RestoreProductModal
        isOpen={showRestoreModal}
        onClose={() => setShowRestoreModal(false)}
        onConfirm={handleRestore}
        product={product}
      />
      <ForceDeleteModal
        isOpen={showForceDeleteModal}
        onClose={() => setShowForceDeleteModal(false)}
        onConfirm={handleForceDelete}
        product={product}
      />
    </DropdownMenu>
  );
}




--- FILE: app/api/admin/products/route.ts ---


/**
 * Admin Products API Route
 * GET /api/admin/products - List products (with filters)
 * POST /api/admin/products - Create new product
 * 
 * Protected route - requires authentication
 */

import { NextRequest, NextResponse } from 'next/server';
import { getCollections, ObjectId } from '@/lib/db';
import { mapMongoProduct } from '@/lib/utils/productMapper';
import { generateProductSchema } from '@/lib/utils/schema';
import { z } from 'zod';
import { handleValidationError } from '@/lib/utils/validation-errors';
import { withAuthAdmin, AuthenticatedRequest } from '@/lib/middleware/authMiddleware';

export const dynamic = 'force-dynamic';

/**
 * Auto-generate alt text for product images
 * Format: {originalAlt} - Shop Gáº¥u BÃ´ng
 */
function generateImageAltText(originalAlt: string | undefined, productName: string, siteName: string = 'Shop Gáº¥u BÃ´ng'): string {
  if (originalAlt && originalAlt.trim()) {
    // If alt text already contains site name, don't duplicate
    if (originalAlt.includes(siteName)) {
      return originalAlt;
    }
    return `${originalAlt} - ${siteName}`;
  }
  // Fallback to product name + site name
  return productName ? `${productName} - ${siteName}` : siteName;
}

/**
 * Generate Product Schema (JSON-LD) from product data
 */
function generateProductSchemaFromData(productDoc: any, siteUrl: string = 'https://shop-gaubong.com'): object | null {
  try {
    // Get price (prefer sale price, fallback to regular price)
    const price = productDoc.productDataMetaBox?.salePrice || 
                  productDoc.productDataMetaBox?.regularPrice || 
                  productDoc.minPrice || 
                  0;
    
    // Get stock status
    const stockStatus = productDoc.productDataMetaBox?.stockStatus || 
                       (productDoc.productDataMetaBox?.stockQuantity > 0 ? 'instock' : 'outofstock');
    
    // Get availability
    const availability = stockStatus === 'instock' ? 'InStock' : 
                        stockStatus === 'outofstock' ? 'OutOfStock' : 'PreOrder';
    
    // Get image URL (from _thumbnail_id or images array)
    let imageUrl: string | null = null;
    if (productDoc._thumbnail_id) {
      // TODO: Resolve thumbnail_id to URL when media API is available
      // For now, use first image from images array if available
      imageUrl = productDoc.images?.[0] || null;
    } else if (productDoc.images && productDoc.images.length > 0) {
      imageUrl = productDoc.images[0];
    }
    
    // Get category name
    const categoryName = productDoc.categoryId 
      ? 'Gáº¥u bÃ´ng' // TODO: Resolve categoryId to name
      : productDoc.category || 'Gáº¥u bÃ´ng';
    
    // Build URL
    const productUrl = `${siteUrl}/products/${productDoc.slug || productDoc._id.toString()}`;
    
    // Extract size from variations if available
    const additionalProperties: Array<{ name: string; value: string }> = [];
    if (productDoc.productDataMetaBox?.variations && productDoc.productDataMetaBox.variations.length > 0) {
      // Check if variations have Size attribute
      const sizeVariations = productDoc.productDataMetaBox.variations
        .map((v: any) => v.attributes?.Size || v.attributes?.size)
        .filter(Boolean);
      
      if (sizeVariations.length > 0) {
        // Get unique sizes
        const uniqueSizes = [...new Set(sizeVariations)];
        if (uniqueSizes.length === 1) {
          // Single size variant
          additionalProperties.push({ name: 'Size', value: String(uniqueSizes[0]) });
        } else if (uniqueSizes.length > 1) {
          // Multiple sizes - use first one or comma-separated
          additionalProperties.push({ name: 'Size', value: uniqueSizes.join(', ') });
        }
      }
    }
    
    // Generate schema
    const schema = generateProductSchema({
      name: productDoc.name,
      description: productDoc.seo?.seoDescription || productDoc.shortDescription || productDoc.description || null,
      image: imageUrl,
      price: price > 0 ? String(price) : null,
      currency: 'VND',
      sku: productDoc.productDataMetaBox?.sku || productDoc.sku || null,
      availability,
      brand: 'Shop Gáº¥u BÃ´ng',
      category: categoryName,
      url: productUrl,
      additionalProperties: additionalProperties.length > 0 ? additionalProperties : undefined,
    });
    
    return schema;
  } catch (error) {
    console.error('Error generating product schema:', error);
    return null;
  }
}

// Product schema for validation
const productSchema = z.object({
  name: z.string().min(1),
  slug: z.string().min(1),
  description: z.string().optional(),
  shortDescription: z.string().optional(),
  sku: z.string().optional(),
  minPrice: z.number().min(0),
  maxPrice: z.number().min(0).optional(),
  // Image fields (new structure)
  _thumbnail_id: z.string().optional(), // Attachment ID for featured image
  _product_image_gallery: z.string().optional(), // Comma-separated attachment IDs for gallery
  // Keep images for backward compatibility (will be removed later)
  images: z.array(z.string()).optional(),
  category: z.string().optional(),
  tags: z.array(z.string()).default([]),
  variants: z.array(z.object({
    id: z.string(),
    size: z.string(),
    color: z.string().optional(),
    colorCode: z.string().optional(),
    price: z.number().min(0),
    stock: z.number().min(0),
    image: z.string().optional(),
    sku: z.string().optional(),
  })).default([]),
  isHot: z.boolean().default(false),
  isActive: z.boolean().default(true),
  status: z.enum(['draft', 'publish', 'trash']).default('draft'),
  visibility: z.enum(['public', 'private', 'password']).optional(),
  password: z.string().optional(),
  scheduledDate: z.string().optional(), // ISO date string
  length: z.number().optional(),
  width: z.number().optional(),
  height: z.number().optional(),
  weight: z.number().optional(),
  volumetricWeight: z.number().optional(),
  // Phase 1: SEO Meta Box fields
  seo: z.object({
    focusKeyword: z.string().optional(),
    seoTitle: z.string().optional(),
    seoDescription: z.string().optional(),
    slug: z.string().optional(),
    canonicalUrl: z.string().optional(),
    robotsMeta: z.string().optional(),
    ogImage: z.string().optional(),
    ogImageId: z.string().optional(),
    socialDescription: z.string().optional(),
  }).optional(),
  // Phase 2: Gift & Media fields
  giftFeatures: z.object({
    giftWrapping: z.boolean().default(false),
    giftWrappingPrice: z.number().optional(),
    giftMessageEnabled: z.boolean().default(false),
    giftMessageMaxLength: z.number().optional(),
    giftCardEnabled: z.boolean().default(false),
    giftCardTypes: z.array(z.string()).optional(),
    giftDeliveryDateEnabled: z.boolean().default(false),
    giftCategories: z.array(z.string()).optional(),
    giftSuggestions: z.array(z.string()).optional(),
  }).optional(),
  mediaExtended: z.object({
    videos: z.array(z.object({
      url: z.string(),
      type: z.enum(['youtube', 'vimeo', 'upload']),
      thumbnail: z.string().optional(),
    })).optional(),
    view360Images: z.array(z.string()).optional(),
    imageAltTexts: z.record(z.string(), z.string()).optional(),
  }).optional(),
  // Product Data Meta Box fields - Use passthrough to keep all fields
  productDataMetaBox: z.object({
    productType: z.enum(['simple', 'variable', 'grouped', 'external']).optional(),
    isVirtual: z.boolean().optional(),
    isDownloadable: z.boolean().optional(),
    costPrice: z.number().optional(),
    regularPrice: z.number().optional(),
    salePrice: z.number().optional(),
    salePriceStartDate: z.string().optional(),
    salePriceEndDate: z.string().optional(),
    downloadableFiles: z.array(z.object({
      id: z.string(),
      name: z.string(),
      url: z.string(),
      downloadLimit: z.number().optional(),
      downloadExpiry: z.string().optional(),
    })).optional(),
    sku: z.string().optional(),
    manageStock: z.boolean().optional(),
    stockQuantity: z.number().optional(),
    stockStatus: z.enum(['instock', 'outofstock', 'onbackorder']).optional(),
    lowStockThreshold: z.number().optional(),
    backorders: z.enum(['no', 'notify', 'yes']).optional(),
    soldIndividually: z.boolean().optional(),
    weight: z.number().optional(),
    length: z.number().optional(),
    width: z.number().optional(),
    height: z.number().optional(),
    shippingClass: z.string().optional(),
    attributes: z.array(z.object({
      id: z.string(),
      name: z.string(),
      isGlobal: z.boolean().optional(),
      globalAttributeId: z.string().optional(),
      values: z.array(z.string()),
      usedForVariations: z.boolean().optional(),
      colorCodes: z.record(z.string(), z.string()).optional(),
    }).passthrough()).optional(),
    variations: z.array(z.object({
      id: z.string(),
      name: z.string(),
      sku: z.string().optional(),
      costPrice: z.number().optional(),
      regularPrice: z.number().optional(),
      salePrice: z.number().optional(),
      stockQuantity: z.number().optional(),
      image: z.string().optional(),
      attributes: z.record(z.string(), z.string()),
    }).passthrough()).optional(),
    purchaseNote: z.string().optional(),
    menuOrder: z.number().optional(),
    enableReviews: z.boolean().optional(),
  }).passthrough().optional(),
}).passthrough().refine((data) => {
  // Validate: salePrice must be less than regularPrice if both exist
  if (data.productDataMetaBox?.salePrice !== undefined && 
      data.productDataMetaBox?.regularPrice !== undefined) {
    if (data.productDataMetaBox.salePrice >= data.productDataMetaBox.regularPrice) {
      return false;
    }
  }
  return true;
}, {
  message: "GiÃ¡ khuyáº¿n mÃ£i pháº£i nhá» hÆ¡n giÃ¡ gá»‘c",
  path: ["productDataMetaBox", "salePrice"],
}).refine((data) => {
  // Validate: variations salePrice must be less than regularPrice
  if (data.productDataMetaBox?.variations) {
    for (const variation of data.productDataMetaBox.variations) {
      if (variation.salePrice !== undefined && variation.regularPrice !== undefined) {
        if (variation.salePrice >= variation.regularPrice) {
          return false;
        }
      }
    }
  }
  return true;
}, {
  message: "GiÃ¡ khuyáº¿n mÃ£i cá»§a biáº¿n thá»ƒ pháº£i nhá» hÆ¡n giÃ¡ gá»‘c",
  path: ["productDataMetaBox", "variations"],
});

export async function GET(request: NextRequest) {
  return withAuthAdmin(request, async (req: AuthenticatedRequest) => {
    try {
      // Permission: product:read (checked by middleware)
      const searchParams = req.nextUrl.searchParams;
    const page = parseInt(searchParams.get('page') || '1', 10);
    const perPage = parseInt(searchParams.get('per_page') || '10', 10);
    const search = searchParams.get('search');
    const status = searchParams.get('status');
    const trashed = searchParams.get('trashed') === 'true';
    const stockStatus = searchParams.get('stock_status');
    const category = searchParams.get('category');
    const brand = searchParams.get('brand');
    const priceMin = searchParams.get('price_min');
    const priceMax = searchParams.get('price_max');
    
    const { products } = await getCollections();
    
    // Build query
    const query: any = {};
    
    // Soft Delete Logic: Handle trashed and status params
    if (trashed || status === 'trash') {
      // Show only trashed products (deletedAt IS NOT NULL)
      query.deletedAt = { $ne: null };
    } else {
      // Default: Show only non-trashed products (deletedAt IS NULL or not exists)
      query.$or = [
        { deletedAt: null },
        { deletedAt: { $exists: false } }
      ];
    }
    
    // Status filter (active, draft, etc.)
    if (status && status !== 'trash') {
      query.status = status;
    }
    
    // Search: name, SKU, barcode
    if (search) {
      query.$and = query.$and || [];
      query.$and.push({
        $or: [
          { name: { $regex: search, $options: 'i' } },
          { description: { $regex: search, $options: 'i' } },
          { sku: { $regex: search, $options: 'i' } },
          // Search in productDataMetaBox.sku if exists
          { 'productDataMetaBox.sku': { $regex: search, $options: 'i' } },
        ],
      });
    }
    
    // Category filter
    if (category) {
      try {
        const categoryId = new ObjectId(category);
        query.$or = query.$or || [];
        query.$or.push(
          { category: category },
          { categoryId: category },
          { category: categoryId },
          { categoryId: categoryId.toString() }
        );
      } catch {
        // If category is not a valid ObjectId, search by name
        query.category = { $regex: category, $options: 'i' };
      }
    }
    
    // Brand filter (if brand field exists)
    if (brand) {
      query.brand = brand;
    }
    
    // Price range filter
    if (priceMin || priceMax) {
      const priceQuery: any = {};
      if (priceMin) {
        priceQuery.$gte = parseFloat(priceMin);
      }
      if (priceMax) {
        priceQuery.$lte = parseFloat(priceMax);
      }
      if (Object.keys(priceQuery).length > 0) {
        query.$or = query.$or || [];
        query.$or.push(
          { price: priceQuery },
          { minPrice: priceQuery },
          { 'productDataMetaBox.regularPrice': priceQuery },
          { 'productDataMetaBox.salePrice': priceQuery }
        );
      }
    }
    
    // Stock status filter
    if (stockStatus) {
      query.$or = query.$or || [];
      query.$or.push(
        { stockStatus: stockStatus },
        { 'productDataMetaBox.stockStatus': stockStatus }
      );
    }
    
    // Fix $or array if it exists and has only one condition
    if (query.$or && Array.isArray(query.$or) && query.$or.length === 1) {
      Object.assign(query, query.$or[0]);
      delete query.$or;
    }
    
    // Fetch products
    const [productsList, total, trashCount] = await Promise.all([
      products
        .find(query)
        .sort({ createdAt: -1 })
        .skip((page - 1) * perPage)
        .limit(perPage)
        .toArray(),
      products.countDocuments(query),
      // Count trashed products for trash tab badge
      products.countDocuments({ deletedAt: { $ne: null } }),
    ]);
    
    const mappedProducts = productsList.map((product) => mapMongoProduct(product));
    const totalPages = Math.ceil(total / perPage);
    
    return NextResponse.json({
      products: mappedProducts,
      pagination: {
        total,
        totalPages,
        currentPage: page,
        perPage,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1,
      },
      filters: {
        trashCount,
      },
    });
  } catch (error: any) {
    console.error('[Admin Products API] Error:', error);
    return NextResponse.json(
      { 
        error: error.message || 'Failed to fetch products',
        details: process.env.NODE_ENV === 'development' 
          ? { stack: error.stack }
          : undefined,
      },
      { status: 500 }
    );
    }
  }, 'product:create');
}

export async function POST(request: NextRequest) {
  return withAuthAdmin(request, async (req: AuthenticatedRequest) => {
    try {
      // Permission: product:create (checked by middleware)
      const body = await req.json();
    
    // Validate input - Schema already has passthrough
    const validatedData = productSchema.parse(body);
    
    const { products, categories } = await getCollections();
    
    // Check if slug already exists (prevent duplicate products)
    const existingProduct = await products.findOne({ slug: validatedData.slug });
    if (existingProduct) {
      return NextResponse.json(
        { error: 'Product with this slug already exists' },
        { status: 409 }
      );
    }

    // Additional check: prevent duplicate by name (in case of race condition)
    // Only check if name is provided and not empty
    // This helps catch race conditions where two requests create products with same name simultaneously
    if (validatedData.name && validatedData.name.trim()) {
      const existingByName = await products.findOne({ 
        name: validatedData.name.trim()
      });
      if (existingByName) {
        // Check if it was created very recently (within last 10 seconds) - likely a race condition
        const timeDiff = Date.now() - existingByName.createdAt.getTime();
        if (timeDiff < 10000) {
          return NextResponse.json(
            { error: 'Product with this name was just created. Please refresh the page.' },
            { status: 409 }
          );
        }
        // Otherwise, it's a legitimate duplicate
        return NextResponse.json(
          { error: 'Product with this name already exists.' },
          { status: 409 }
        );
      }
    }

    // Map category to categoryId if category is provided as string
    let categoryId: string | undefined = undefined;
    if (validatedData.category) {
      // Try to find category by ID or name
      const category = await categories.findOne({
        $or: [
          { _id: new ObjectId(validatedData.category) },
          { name: validatedData.category },
          { slug: validatedData.category },
        ],
      });
      if (category) {
        categoryId = category._id.toString();
      }
    }
    
    // Calculate minPrice if not provided and variants exist
    let minPrice = validatedData.minPrice;
    if (!minPrice && validatedData.variants && validatedData.variants.length > 0) {
      const prices = validatedData.variants
        .map((v) => v.price)
        .filter((p) => !isNaN(p) && p >= 0);
      if (prices.length > 0) {
        minPrice = Math.min(...prices);
      }
    }
    if (!minPrice || minPrice < 0) {
      minPrice = 0; // Default to 0 if no price provided
    }

    // Calculate volumetric weight if dimensions provided
    let volumetricWeight = validatedData.volumetricWeight;
    if (!volumetricWeight && validatedData.length && validatedData.width && validatedData.height) {
      // Validate dimensions are positive
      if (validatedData.length > 0 && validatedData.width > 0 && validatedData.height > 0) {
        volumetricWeight = (validatedData.length * validatedData.width * validatedData.height) / 6000;
      }
    }
    
    // Create product document
    const productDoc: any = {
      ...validatedData,
      minPrice,
      volumetricWeight,
      createdAt: new Date(),
      updatedAt: new Date(),
      version: 1, // Initialize version for optimistic locking
    };
    
    // Handle scheduledDate - convert ISO string to Date if provided
    if (validatedData.scheduledDate) {
      productDoc.scheduledDate = new Date(validatedData.scheduledDate);
    }
    
    // Handle password - only save if visibility is password
    if (validatedData.visibility === 'password' && validatedData.password) {
      productDoc.password = validatedData.password;
    }

    // Replace category string with categoryId
    if (categoryId) {
      productDoc.categoryId = categoryId;
      delete productDoc.category;
    }
    
    // Convert productDataMetaBox.variations â†’ variants array if variations exist
    if (productDoc.productDataMetaBox?.variations && productDoc.productDataMetaBox.variations.length > 0) {
      const convertedVariants = productDoc.productDataMetaBox.variations.map((variation: any) => {
        // Extract size and color from attributes
        let size = '';
        let color = '';
        let colorCode = '';
        
        if (variation.attributes) {
          Object.entries(variation.attributes).forEach(([attrName, value]) => {
            const attrNameLower = attrName.toLowerCase();
            if (attrNameLower.includes('size') || attrNameLower === 'pa_size' || attrNameLower === 'kÃ­ch thÆ°á»›c') {
              size = String(value);
            } else if (attrNameLower.includes('color') || attrNameLower === 'pa_color' || attrNameLower === 'mÃ u') {
              color = String(value);
            }
          });
        }
        
        // Use salePrice if available and valid, otherwise use regularPrice
        const price = variation.salePrice && variation.regularPrice && variation.salePrice < variation.regularPrice
          ? variation.salePrice
          : variation.regularPrice || 0;
        
        return {
          id: variation.id || `var_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          size,
          color: color || undefined,
          colorCode: colorCode || undefined,
          price,
          stock: variation.stockQuantity || 0,
          image: variation.image || undefined,
          sku: variation.sku || undefined,
        };
      });
      
      // Set variants array (will be used by frontend)
      productDoc.variants = convertedVariants;
      // Also keep productDataMetaBox.variations for admin editing
      // (don't delete it, keep both formats)
    }
    
    // Auto-generate alt text for images (Auto-Alt Text feature)
    const siteName = 'Shop Gáº¥u BÃ´ng';
    if (!productDoc.mediaExtended) {
      productDoc.mediaExtended = {};
    }
    if (!productDoc.mediaExtended.imageAltTexts) {
      productDoc.mediaExtended.imageAltTexts = {};
    }
    
    // Generate alt text for featured image
    if (productDoc._thumbnail_id) {
      const featuredAlt = generateImageAltText(
        productDoc.mediaExtended.imageAltTexts[productDoc._thumbnail_id],
        validatedData.name,
        siteName
      );
      productDoc.mediaExtended.imageAltTexts[productDoc._thumbnail_id] = featuredAlt;
    }
    
    // Generate alt text for gallery images
    if (productDoc._product_image_gallery) {
      const galleryIds = productDoc._product_image_gallery.split(',').filter(Boolean);
      galleryIds.forEach((imageId: string) => {
        const trimmedId = imageId.trim();
        if (trimmedId && !productDoc.mediaExtended.imageAltTexts[trimmedId]) {
          const galleryAlt = generateImageAltText(
            undefined,
            validatedData.name,
            siteName
          );
          productDoc.mediaExtended.imageAltTexts[trimmedId] = galleryAlt;
        }
      });
    }
    
    // Populate images array for backward compatibility and frontend display
    // Priority: Use images from payload (already URLs), then try to resolve from _thumbnail_id/_product_image_gallery
    if (!productDoc.images || productDoc.images.length === 0) {
      productDoc.images = [];
      
      // Priority 1: Use images from payload if provided (these are already URLs)
      if (validatedData.images && Array.isArray(validatedData.images) && validatedData.images.length > 0) {
        productDoc.images = validatedData.images.filter((url: string) => 
          typeof url === 'string' && url.length > 0
        );
      } else {
        // Priority 2: Try to resolve from _thumbnail_id
        if (productDoc._thumbnail_id) {
          // If _thumbnail_id is already a URL, use it directly
          if (productDoc._thumbnail_id.startsWith('http://') || productDoc._thumbnail_id.startsWith('https://')) {
            productDoc.images.push(productDoc._thumbnail_id);
          }
          // If it's a pathname, we'll try to resolve it in the mapper using images array
        }
        
        // Priority 3: Add gallery image URLs if _product_image_gallery exists
        if (productDoc._product_image_gallery) {
          const galleryIds = productDoc._product_image_gallery.split(',').filter(Boolean);
          galleryIds.forEach((imageId: string) => {
            const trimmedId = imageId.trim();
            // If imageId is already a URL, add it
            if (trimmedId.startsWith('http://') || trimmedId.startsWith('https://')) {
              productDoc.images.push(trimmedId);
            }
          });
        }
      }
    }
    
    // Generate and save Product Schema (JSON-LD)
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://shop-gaubong.com';
    const productJsonLdSchema = generateProductSchemaFromData(productDoc, siteUrl);
    if (productJsonLdSchema) {
      productDoc._productSchema = productJsonLdSchema; // Save schema to database
    }
    const result = await products.insertOne(productDoc);
    
    // Fetch created product
    const createdProduct = await products.findOne({ _id: result.insertedId });
    
    if (!createdProduct) {
      return NextResponse.json(
        { error: 'Failed to create product' },
        { status: 500 }
      );
    }
    
    const mappedProduct = mapMongoProduct(createdProduct);
    
    return NextResponse.json(
      { product: mappedProduct },
      { status: 201 }
    );
  } catch (error: any) {
    // Handle Zod validation errors
    const validationError = handleValidationError(error);
    if (validationError) {
      return validationError;
    }
    
    console.error('[Admin Products API] Error:', error);
    return NextResponse.json(
      { 
        error: error.message || 'Failed to create product',
        details: process.env.NODE_ENV === 'development' 
          ? { stack: error.stack }
          : undefined,
      },
      { status: 500 }
    );
    }
  }, 'product:create');
}




--- FILE: app/api/cms/products/route.ts ---


/**
 * Public Products API Route
 * GET /api/cms/products
 * 
 * Fetch products from MongoDB (public endpoint)
 */

import { NextRequest, NextResponse } from 'next/server';
import { getCollections, ObjectId } from '@/lib/db';
import { mapMongoProduct } from '@/lib/utils/productMapper';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    
    // Parse query parameters
    const page = parseInt(searchParams.get('page') || '1', 10);
    const perPage = parseInt(searchParams.get('per_page') || '10', 10);
    const search = searchParams.get('search');
    const category = searchParams.get('category');
    const featured = searchParams.get('featured') === 'true';
    const minPrice = searchParams.get('min_price') ? parseFloat(searchParams.get('min_price')!) : undefined;
    const maxPrice = searchParams.get('max_price') ? parseFloat(searchParams.get('max_price')!) : undefined;
    const minLength = searchParams.get('min_length') ? parseFloat(searchParams.get('min_length')!) : undefined;
    const maxLength = searchParams.get('max_length') ? parseFloat(searchParams.get('max_length')!) : undefined;
    const material = searchParams.get('material');
    const size = searchParams.get('size');
    const color = searchParams.get('color');
    
    const { products, categories } = await getCollections();
    
    // Build MongoDB query
    // Only show published, active products that are not deleted
    const query: any = {
      status: 'publish',
      isActive: true,
      $or: [
        { deletedAt: null },
        { deletedAt: { $exists: false } },
      ],
    };
    
    // Search filter
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { sku: { $regex: search, $options: 'i' } },
      ];
    }
    
    // Category filter
    if (category) {
      const categoryDoc = await categories.findOne({ slug: category });
      if (categoryDoc) {
        query.category = categoryDoc._id.toString();
      }
    }
    
    // Featured filter
    if (featured) {
      query.isHot = true;
    }
    
    // Price range filter
    if (minPrice !== undefined || maxPrice !== undefined) {
      query.minPrice = {};
      if (minPrice !== undefined) query.minPrice.$gte = minPrice;
      if (maxPrice !== undefined) query.minPrice.$lte = maxPrice;
    }
    
    // Length filter (for size filtering)
    if (minLength !== undefined || maxLength !== undefined) {
      query.length = {};
      if (minLength !== undefined) query.length.$gte = minLength;
      if (maxLength !== undefined) query.length.$lte = maxLength;
    }
    
    // Material filter
    if (material) {
      query.material = { $regex: material, $options: 'i' };
    }
    
    // Size filter (from variants)
    if (size) {
      query['variants.size'] = { $regex: size, $options: 'i' };
    }
    
    // Color filter (from variants)
    if (color) {
      query['variants.color'] = { $regex: color, $options: 'i' };
    }
    
    // Fetch products with pagination
    const [productsList, total] = await Promise.all([
      products
        .find(query)
        .sort({ createdAt: -1 })
        .skip((page - 1) * perPage)
        .limit(perPage)
        .toArray(),
      products.countDocuments(query),
    ]);
    
    // Fetch categories for mapping
    const categoryIds = productsList
      .map(p => p.category)
      .filter(Boolean)
      .filter((id, index, self) => self.indexOf(id) === index); // Unique IDs
    
    const categoryDocs = categoryIds.length > 0
      ? await categories.find({
          $or: [
            ...(categoryIds.filter(id => ObjectId.isValid(String(id))).length > 0
              ? [{ _id: { $in: categoryIds.filter(id => ObjectId.isValid(String(id))).map(id => new ObjectId(String(id))) } }]
              : []),
            ...(categoryIds.filter(id => !ObjectId.isValid(String(id))).length > 0
              ? [{ slug: { $in: categoryIds.filter(id => !ObjectId.isValid(String(id))) } }]
              : []),
          ],
        }).toArray()
      : [];
    
    const categoryMap = new Map<string, any>();
    categoryDocs.forEach(cat => {
      const catId = cat._id.toString();
      categoryMap.set(catId, cat);
      categoryMap.set(cat.slug, cat);
    });
    
    // Map products to frontend format with categories
    const mappedProducts = productsList.map((product) => {
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/b261569c-76a6-4f8c-839c-264dc5457f92',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'route.ts:129',message:'API FULL PRODUCT DOCUMENT',data:{productId:product._id?.toString(),name:product.name,_thumbnail_id:product._thumbnail_id,_product_image_gallery:product._product_image_gallery,images:product.images,imagesLength:product.images?.length,hasVariants:!!product.variants?.length,variantsCount:product.variants?.length,variants:product.variants?.slice(0,2),hasProductDataMetaBox:!!product.productDataMetaBox,productDataMetaBoxAttributes:product.productDataMetaBox?.attributes,productDataMetaBoxVariations:product.productDataMetaBox?.variations,minPrice:product.minPrice,maxPrice:product.maxPrice,regularPrice:product.productDataMetaBox?.regularPrice,salePrice:product.productDataMetaBox?.salePrice},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'H1,H2,H3,H4'})}).catch(()=>{});
      // #endregion
      const mapped = mapMongoProduct(product);
      
      // Populate categories
      if (product.category) {
        const categoryDoc = categoryMap.get(product.category) || 
                           categoryMap.get(String(product.category));
        if (categoryDoc) {
          mapped.categories = [{
            id: parseInt(categoryDoc._id.toString(), 16) || 0,
            name: categoryDoc.name,
            slug: categoryDoc.slug,
          }];
        }
      }
      
      return mapped;
    });
    
    const totalPages = Math.ceil(total / perPage);
    
    return NextResponse.json({
      products: mappedProducts,
      pagination: {
        total,
        totalPages,
        currentPage: page,
        perPage,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1,
      },
    });
  } catch (error: any) {
    console.error('[Products API] Error:', error);
    return NextResponse.json(
      { 
        error: error.message || 'Failed to fetch products',
        details: process.env.NODE_ENV === 'development' 
          ? { stack: error.stack }
          : undefined,
      },
      { status: 500 }
    );
  }
}




--- FILE: lib/utils/slug.ts ---


/**
 * Slug Generation Utility
 * 
 * Converts Vietnamese text to URL-friendly slugs
 * Handles all Vietnamese characters including Ä‘/Ä
 */

/**
 * Generate slug from Vietnamese text
 * 
 * @param text - Vietnamese text to convert
 * @returns URL-friendly slug
 * 
 * @example
 * generateSlug("MÃ u Ä‘á»") // "mau-do"
 * generateSlug("Äá»™ dÃ i") // "do-dai"
 * generateSlug("KÃ­ch thÆ°á»›c") // "kich-thuoc"
 * generateSlug("Äáº­u phá»™ng") // "dau-phong"
 */
export function generateSlug(text: string): string {
  if (!text || typeof text !== 'string') {
    return '';
  }

  return text
    .toLowerCase()
    // Handle Ä‘/Ä BEFORE normalize (Ä‘/Ä are not decomposed by NFD)
    .replace(/Ä‘/g, 'd')
    .replace(/Ä/g, 'd')
    .normalize('NFD') // Decompose characters (Ã© â†’ e + Ì, áº£ â†’ a + Ì‰)
    .replace(/[\u0300-\u036f]/g, '') // Remove diacritics (dáº¥u)
    .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric with hyphen
    .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens
}

/**
 * Validate if a string is a valid slug
 * 
 * @param slug - Slug to validate
 * @returns true if valid slug format
 */
export function isValidSlug(slug: string): boolean {
  if (!slug || typeof slug !== 'string') {
    return false;
  }
  
  // Slug should only contain lowercase letters, numbers, and hyphens
  // Should not start or end with hyphen
  // Should not have consecutive hyphens
  return /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(slug);
}

/**
 * Generate a random short ID (4-6 characters)
 * Used as suffix for duplicate slugs
 * 
 * @returns Random alphanumeric string
 */
export function generateShortId(): string {
  // Generate 4-6 character random string using alphanumeric
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  const length = 4 + Math.floor(Math.random() * 3); // 4-6 chars
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * Generate unique slug with duplicate check
 * If slug exists, appends random short ID suffix
 * 
 * @param baseSlug - Base slug to check
 * @param checkExists - Function to check if slug exists (returns Promise<boolean>)
 * @returns Unique slug
 */
export async function generateUniqueSlug(
  baseSlug: string,
  checkExists: (slug: string) => Promise<boolean>
): Promise<string> {
  if (!baseSlug) {
    return '';
  }

  // Check if base slug is available
  const exists = await checkExists(baseSlug);
  if (!exists) {
    return baseSlug;
  }

  // Generate unique slug with random suffix
  let attempts = 0;
  const maxAttempts = 10; // Prevent infinite loop
  
  while (attempts < maxAttempts) {
    const suffix = generateShortId();
    const uniqueSlug = `${baseSlug}-${suffix}`;
    
    const slugExists = await checkExists(uniqueSlug);
    if (!slugExists) {
      return uniqueSlug;
    }
    
    attempts++;
  }

  // Fallback: use timestamp if all attempts failed
  return `${baseSlug}-${Date.now().toString(36)}`;
}



--- FILE: lib/utils/sanitizeHtml.ts ---


/**
 * HTML Sanitization Utility
 * 
 * Sanitizes HTML content to prevent XSS attacks
 * Uses isomorphic-dompurify for both client and server-side sanitization
 */

import DOMPurify from 'isomorphic-dompurify';

/**
 * Sanitize HTML content (works on both client and server)
 * 
 * @param html - HTML string to sanitize
 * @returns Sanitized HTML string
 * 
 * @example
 * ```tsx
 * const sanitized = sanitizeHtml(product.description);
 * <div dangerouslySetInnerHTML={{ __html: sanitized }} />
 * ```
 */
export function sanitizeHtml(html: string | null | undefined): string {
  if (!html || typeof html !== 'string') {
    return '';
  }

  try {
    return DOMPurify.sanitize(html, {
      // Allow common HTML tags for rich content
      ALLOWED_TAGS: [
        'p', 'br', 'strong', 'em', 'u', 's', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'ul', 'ol', 'li', 'a', 'img', 'blockquote', 'code', 'pre', 'span', 'div',
        'table', 'thead', 'tbody', 'tr', 'th', 'td',
      ],
      ALLOWED_ATTR: [
        'href', 'target', 'rel', 'src', 'alt', 'title', 'class', 'id',
        'width', 'height', 'style', 'data-*',
      ],
      // Allow data attributes for custom functionality
      ALLOW_DATA_ATTR: true,
      // Add rel="noopener noreferrer" to external links automatically
      ADD_ATTR: ['target'],
      ADD_TAGS: [],
    });
  } catch (error) {
    // Fallback: return empty string if DOMPurify fails
    console.error('Error sanitizing HTML:', error);
    return '';
  }
}

/**
 * Sanitize HTML content for server-side rendering
 * 
 * Note: Now uses isomorphic-dompurify which works on both client and server.
 * This function is kept for backward compatibility but now just calls sanitizeHtml.
 * 
 * @param html - HTML string to sanitize
 * @returns Sanitized HTML string
 */
export function sanitizeHtmlServer(html: string | null | undefined): string {
  // Now uses the same implementation as sanitizeHtml (isomorphic-dompurify)
  return sanitizeHtml(html);
}



--- FILE: app/admin/products/page.tsx ---


'use client';

import { useState, useEffect, useCallback } from 'react';
import Link from 'next/link';
import { useSearchParams, useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Plus, Search, CheckSquare } from 'lucide-react';
import type { MappedProduct } from '@/lib/utils/productMapper';
import { ProductListTabs, type ProductListTab } from '@/components/admin/products/ProductListTabs';
import { ProductDataGrid } from '@/components/admin/products/ProductDataGrid';
import { ProductFilters } from '@/components/admin/products/ProductFilters';
import { BulkActionsBar } from '@/components/admin/products/BulkActionsBar';
import { useToastContext } from '@/components/providers/ToastProvider';
import { useProductFilters } from '@/lib/hooks/useProductFilters';

export default function AdminProductsPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { showToast } = useToastContext();
  
  const [products, setProducts] = useState<MappedProduct[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [page, setPage] = useState(parseInt(searchParams.get('page') || '1', 10));
  const [totalPages, setTotalPages] = useState(1);
  const [total, setTotal] = useState(0);
  const [trashCount, setTrashCount] = useState(0);
  const [selectedProducts, setSelectedProducts] = useState<string[]>([]);
  const [searchDebounceTimer, setSearchDebounceTimer] = useState<NodeJS.Timeout | null>(null);
  const [deletingProducts, setDeletingProducts] = useState<Set<string>>(new Set());
  
  // Get active tab from URL or default to 'all'
  const activeTab: ProductListTab = (searchParams.get('tab') as ProductListTab) || 'all';
  
  // Product filters
  const { filters, updateFilter, clearFilters, hasActiveFilters } = useProductFilters();
  
  // Search state (separate from filters for debouncing)
  const [search, setSearch] = useState(searchParams.get('search') || '');

  // Debounce search to prevent race conditions
  useEffect(() => {
    if (searchDebounceTimer) {
      clearTimeout(searchDebounceTimer);
    }
    
    const timer = setTimeout(() => {
      setPage(1); // Reset to page 1 when search changes
      updateFilter('search', search || undefined);
    }, 300);
    
    setSearchDebounceTimer(timer);
    
    return () => {
      if (timer) clearTimeout(timer);
    };
  }, [search]);

  // Reset page to 1 when filters change (except search which is handled separately)
  useEffect(() => {
    // Check if any filter (except search) has changed
    const hasFilterChanged = filters.category || filters.brand || 
                             filters.priceMin !== null || filters.priceMax !== null || 
                             filters.stockStatus;
    
    if (hasFilterChanged && page !== 1) {
      setPage(1);
      // Update URL to remove page param
      const params = new URLSearchParams(searchParams.toString());
      params.delete('page');
      router.push(`/admin/products?${params.toString()}`);
    }
  }, [filters.category, filters.brand, filters.priceMin, filters.priceMax, filters.stockStatus]);

  // Fetch products when page, tab, or filters change
  useEffect(() => {
    fetchProducts();
  }, [page, activeTab, filters]);

  // Update URL when tab changes
  const handleTabChange = useCallback((tab: ProductListTab) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set('tab', tab);
    params.delete('page'); // Reset to page 1 when changing tab
    router.push(`/admin/products?${params.toString()}`);
  }, [searchParams, router]);

  const fetchProducts = async () => {
    setLoading(true);
    setError(null);
    try {
      const params = new URLSearchParams({
        page: page.toString(),
        per_page: '20',
      });

      // Add search (from filters or local search state)
      const searchValue = filters.search || search;
      if (searchValue) {
        params.append('search', searchValue);
      }

      // Add tab filters
      if (activeTab === 'trash') {
        params.append('trashed', 'true');
      } else if (activeTab === 'active') {
        params.append('status', 'publish');
      } else if (activeTab === 'outofstock') {
        params.append('stock_status', 'outofstock');
      }

      // Add advanced filters
      if (filters.category) {
        params.append('category', filters.category);
      }
      if (filters.brand) {
        params.append('brand', filters.brand);
      }
      if (filters.priceMin !== null && filters.priceMin !== undefined) {
        params.append('price_min', filters.priceMin.toString());
      }
      if (filters.priceMax !== null && filters.priceMax !== undefined) {
        params.append('price_max', filters.priceMax.toString());
      }
      if (filters.stockStatus && activeTab !== 'outofstock') {
        params.append('stock_status', filters.stockStatus);
      }

      const response = await fetch(`/api/admin/products?${params}`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();

      setProducts(data.products || []);
      setTotalPages(data.pagination?.totalPages || 1);
      setTotal(data.pagination?.total || 0);
      setTrashCount(data.filters?.trashCount || 0);
    } catch (error: any) {
      console.error('Error fetching products:', error);
      setError(error instanceof Error ? error : new Error('KhÃ´ng thá»ƒ táº£i danh sÃ¡ch sáº£n pháº©m'));
      showToast('KhÃ´ng thá»ƒ táº£i danh sÃ¡ch sáº£n pháº©m', 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (id: string) => {
    // Add to deleting set
    setDeletingProducts((prev) => new Set(prev).add(id));
    
    try {
      const response = await fetch(`/api/admin/products/${id}`, {
        method: 'DELETE',
      });

      if (response.ok) {
        showToast('ÄÃ£ chuyá»ƒn vÃ o thÃ¹ng rÃ¡c', 'success');
        fetchProducts();
      } else {
        const errorData = await response.json().catch(() => ({}));
        showToast(errorData.error || 'KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m', 'error');
      }
    } catch (error) {
      console.error('Error deleting product:', error);
      showToast('KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m', 'error');
    } finally {
      // Remove from deleting set
      setDeletingProducts((prev) => {
        const next = new Set(prev);
        next.delete(id);
        return next;
      });
    }
  };

  const handleRestore = async (id: string) => {
    try {
      const response = await fetch(`/api/admin/products/${id}/restore`, {
        method: 'PATCH',
      });

      if (response.ok) {
        showToast('ÄÃ£ khÃ´i phá»¥c sáº£n pháº©m', 'success');
        fetchProducts();
      } else {
        const errorData = await response.json().catch(() => ({}));
        showToast(errorData.error || 'KhÃ´ng thá»ƒ khÃ´i phá»¥c sáº£n pháº©m', 'error');
      }
    } catch (error) {
      console.error('Error restoring product:', error);
      showToast('KhÃ´ng thá»ƒ khÃ´i phá»¥c sáº£n pháº©m', 'error');
    }
  };

  const handleForceDelete = async (id: string) => {
    try {
      const response = await fetch(`/api/admin/products/${id}/force`, {
        method: 'DELETE',
      });

      if (response.ok) {
        showToast('ÄÃ£ xÃ³a vÄ©nh viá»…n sáº£n pháº©m', 'success');
        fetchProducts();
      } else {
        const errorData = await response.json().catch(() => ({}));
        showToast(errorData.error || 'KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m', 'error');
      }
    } catch (error) {
      console.error('Error force deleting product:', error);
      showToast('KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m', 'error');
    }
  };

  const handleDuplicate = async (id: string) => {
    try {
      const response = await fetch(`/api/admin/products/${id}/duplicate`, {
        method: 'POST',
      });

      if (response.ok) {
        showToast('ÄÃ£ táº¡o báº£n sao sáº£n pháº©m', 'success');
        fetchProducts();
      } else {
        const error = await response.json();
        showToast(error.error || 'CÃ³ lá»—i xáº£y ra khi táº¡o báº£n sao', 'error');
      }
    } catch (error) {
      console.error('Error duplicating product:', error);
      showToast('CÃ³ lá»—i xáº£y ra khi táº¡o báº£n sao', 'error');
    }
  };

  const handleStatusChange = async (id: string, status: 'draft' | 'publish') => {
    try {
      const response = await fetch(`/api/admin/products/${id}/quick-update`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status }),
      });

      if (response.ok) {
        showToast('ÄÃ£ cáº­p nháº­t tráº¡ng thÃ¡i', 'success');
        fetchProducts();
      } else {
        const errorData = await response.json().catch(() => ({}));
        showToast(errorData.error || 'KhÃ´ng thá»ƒ cáº­p nháº­t tráº¡ng thÃ¡i', 'error');
      }
    } catch (error) {
      console.error('Error updating status:', error);
      showToast('KhÃ´ng thá»ƒ cáº­p nháº­t tráº¡ng thÃ¡i', 'error');
    }
  };

  const handleProductUpdate = (updatedProduct: MappedProduct) => {
    // Optimistic update: update product in local state
    setProducts((prevProducts) =>
      prevProducts.map((p) => (p.id === updatedProduct.id ? updatedProduct : p))
    );
    // Refetch to ensure consistency
    fetchProducts();
  };

  const toggleSelectProduct = (id: string) => {
    setSelectedProducts((prev) =>
      prev.includes(id) ? prev.filter((p) => p !== id) : [...prev, id]
    );
  };

  const toggleSelectAll = () => {
    if (selectedProducts.length === products.length) {
      setSelectedProducts([]);
    } else {
      setSelectedProducts(products.map((p) => p.id));
    }
  };

  const handleBulkDelete = async () => {
    if (selectedProducts.length === 0) {
      showToast('Vui lÃ²ng chá»n Ã­t nháº¥t má»™t sáº£n pháº©m', 'warning');
      return;
    }

    if (!confirm(`Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a ${selectedProducts.length} sáº£n pháº©m?`)) {
      return;
    }

    try {
      const response = await fetch('/api/admin/products/bulk-action', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ids: selectedProducts,
          action: 'soft_delete',
        }),
      });

      if (response.ok) {
        const data = await response.json();
        showToast(data.message || `ÄÃ£ xÃ³a ${selectedProducts.length} sáº£n pháº©m`, 'success');
        setSelectedProducts([]);
        fetchProducts();
      } else {
        const errorData = await response.json().catch(() => ({}));
        showToast(errorData.error || 'KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m', 'error');
      }
    } catch (error) {
      console.error('Error bulk deleting products:', error);
      showToast('CÃ³ lá»—i xáº£y ra khi xÃ³a sáº£n pháº©m', 'error');
    }
  };

  const handleBulkStatusChange = async (status: 'draft' | 'publish') => {
    if (selectedProducts.length === 0) {
      showToast('Vui lÃ²ng chá»n Ã­t nháº¥t má»™t sáº£n pháº©m', 'warning');
      return;
    }

    try {
      const response = await fetch('/api/admin/products/bulk-action', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ids: selectedProducts,
          action: 'update_status',
          value: status,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        showToast(data.message || `ÄÃ£ cáº­p nháº­t ${selectedProducts.length} sáº£n pháº©m`, 'success');
        setSelectedProducts([]);
        fetchProducts();
      } else {
        const errorData = await response.json().catch(() => ({}));
        showToast(errorData.error || 'KhÃ´ng thá»ƒ cáº­p nháº­t tráº¡ng thÃ¡i', 'error');
      }
    } catch (error) {
      console.error('Error bulk updating status:', error);
      showToast('CÃ³ lá»—i xáº£y ra khi cáº­p nháº­t tráº¡ng thÃ¡i', 'error');
    }
  };

  const handleBulkRestore = async () => {
    if (selectedProducts.length === 0) {
      showToast('Vui lÃ²ng chá»n Ã­t nháº¥t má»™t sáº£n pháº©m', 'warning');
      return;
    }

    try {
      const response = await fetch('/api/admin/products/bulk-action', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ids: selectedProducts,
          action: 'restore',
        }),
      });

      if (response.ok) {
        const data = await response.json();
        showToast(data.message || `ÄÃ£ khÃ´i phá»¥c ${selectedProducts.length} sáº£n pháº©m`, 'success');
        setSelectedProducts([]);
        fetchProducts();
      } else {
        const errorData = await response.json().catch(() => ({}));
        showToast(errorData.error || 'KhÃ´ng thá»ƒ khÃ´i phá»¥c sáº£n pháº©m', 'error');
      }
    } catch (error) {
      console.error('Error bulk restoring products:', error);
      showToast('CÃ³ lá»—i xáº£y ra khi khÃ´i phá»¥c sáº£n pháº©m', 'error');
    }
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">Quáº£n lÃ½ sáº£n pháº©m</h1>
          <p className="text-gray-600 mt-2">Quáº£n lÃ½ táº¥t cáº£ sáº£n pháº©m trong cá»­a hÃ ng</p>
        </div>
        <div className="flex gap-2">
          <Link href="/admin/products/bulk">
            <Button variant="outline">
              <CheckSquare className="w-4 h-4 mr-2" />
              Thao tÃ¡c hÃ ng loáº¡t
            </Button>
          </Link>
          <Link href="/admin/products/new">
            <Button>
              <Plus className="w-4 h-4 mr-2" />
              ThÃªm sáº£n pháº©m
            </Button>
          </Link>
        </div>
      </div>

      <div className="bg-white rounded-lg shadow p-6">
        {/* Tab Navigation */}
        <div className="mb-6">
          <ProductListTabs
            activeTab={activeTab}
            onTabChange={handleTabChange}
            trashCount={trashCount}
          />
        </div>

        {/* Search Bar & Filters */}
        <div className="mb-4 space-y-3">
          <div className="flex items-center gap-2">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
              <Input
                placeholder="TÃ¬m kiáº¿m sáº£n pháº©m, SKU, barcode..."
                value={search}
                onChange={(e) => {
                  setSearch(e.target.value);
                }}
                className="pl-10"
              />
            </div>
            <ProductFilters
              filters={filters}
              onFilterChange={updateFilter}
              onClearFilters={clearFilters}
              hasActiveFilters={hasActiveFilters}
            />
          </div>
        </div>

        {/* Bulk Actions Bar */}
        <BulkActionsBar
          selectedCount={selectedProducts.length}
          isTrashTab={activeTab === 'trash'}
          onBulkDelete={handleBulkDelete}
          onBulkRestore={handleBulkRestore}
          onBulkForceDelete={async () => {
            if (!confirm(`Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a vÄ©nh viá»…n ${selectedProducts.length} sáº£n pháº©m?\n\nHÃ nh Ä‘á»™ng nÃ y khÃ´ng thá»ƒ hoÃ n tÃ¡c!`)) {
              return;
            }
            try {
              const response = await fetch('/api/admin/products/bulk-action', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  ids: selectedProducts,
                  action: 'force_delete',
                }),
              });
              if (response.ok) {
                const data = await response.json();
                showToast(data.message || `ÄÃ£ xÃ³a vÄ©nh viá»…n ${selectedProducts.length} sáº£n pháº©m`, 'success');
                setSelectedProducts([]);
                fetchProducts();
              } else {
                const errorData = await response.json().catch(() => ({}));
                showToast(errorData.error || 'KhÃ´ng thá»ƒ xÃ³a sáº£n pháº©m', 'error');
              }
            } catch (error) {
              showToast('CÃ³ lá»—i xáº£y ra khi xÃ³a sáº£n pháº©m', 'error');
            }
          }}
          onBulkStatusChange={handleBulkStatusChange}
          onBulkUpdatePrice={async (price: number) => {
            try {
              const response = await fetch('/api/admin/products/bulk-action', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  ids: selectedProducts,
                  action: 'update_price',
                  value: price,
                }),
              });
              if (response.ok) {
                const data = await response.json();
                showToast(data.message || `ÄÃ£ cáº­p nháº­t giÃ¡ cho ${selectedProducts.length} sáº£n pháº©m`, 'success');
                setSelectedProducts([]);
                fetchProducts();
              } else {
                const errorData = await response.json().catch(() => ({}));
                showToast(errorData.error || 'KhÃ´ng thá»ƒ cáº­p nháº­t giÃ¡', 'error');
              }
            } catch (error) {
              showToast('CÃ³ lá»—i xáº£y ra khi cáº­p nháº­t giÃ¡', 'error');
            }
          }}
          onBulkUpdateStock={async (value: number, operation: 'set' | 'add' | 'subtract') => {
            try {
              // For add/subtract, we need to fetch current stock first
              // For now, we'll use a simplified approach: set to value for 'set', add/subtract for others
              // This would require additional API support for add/subtract operations
              // For now, we'll just set the stock value
              const response = await fetch('/api/admin/products/bulk-action', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  ids: selectedProducts,
                  action: 'update_stock',
                  value: value, // For add/subtract, this would need to be calculated
                }),
              });
              if (response.ok) {
                const data = await response.json();
                showToast(data.message || `ÄÃ£ cáº­p nháº­t kho cho ${selectedProducts.length} sáº£n pháº©m`, 'success');
                setSelectedProducts([]);
                fetchProducts();
              } else {
                const errorData = await response.json().catch(() => ({}));
                showToast(errorData.error || 'KhÃ´ng thá»ƒ cáº­p nháº­t kho', 'error');
              }
            } catch (error) {
              showToast('CÃ³ lá»—i xáº£y ra khi cáº­p nháº­t kho', 'error');
            }
          }}
          onClearSelection={() => setSelectedProducts([])}
        />

        {/* Data Grid */}
        <ProductDataGrid
          products={products}
          loading={loading}
          error={error}
          selectedProducts={selectedProducts}
          onSelectProduct={toggleSelectProduct}
          onSelectAll={toggleSelectAll}
          isTrashTab={activeTab === 'trash'}
          hasActiveFilters={hasActiveFilters}
          onClearFilters={clearFilters}
          onDelete={handleDelete}
          onRestore={handleRestore}
          onForceDelete={handleForceDelete}
          onDuplicate={handleDuplicate}
          onStatusChange={handleStatusChange}
          onProductUpdate={handleProductUpdate}
          onRetry={fetchProducts}
        />

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="flex justify-center gap-2 mt-4">
            <Button
              variant="outline"
              disabled={page === 1}
              onClick={() => {
                setPage(page - 1);
                const params = new URLSearchParams(searchParams.toString());
                params.set('page', String(page - 1));
                router.push(`/admin/products?${params.toString()}`);
              }}
            >
              TrÆ°á»›c
            </Button>
            <span className="px-4 py-2">
              Trang {page} / {totalPages} ({total} sáº£n pháº©m)
            </span>
            <Button
              variant="outline"
              disabled={page === totalPages}
              onClick={() => {
                setPage(page + 1);
                const params = new URLSearchParams(searchParams.toString());
                params.set('page', String(page + 1));
                router.push(`/admin/products?${params.toString()}`);
              }}
            >
              Sau
            </Button>
          </div>
        )}

        {/* Trash Warning */}
        {activeTab === 'trash' && (
          <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
            <p className="text-sm text-yellow-800">
              âš ï¸ Sáº£n pháº©m trong thÃ¹ng rÃ¡c sáº½ tá»± Ä‘á»™ng bá»‹ xÃ³a sau 30 ngÃ y
            </p>
          </div>
        )}
      </div>
    </div>
  );
}

